<!doctype html><html lang=zh-cn data-theme=dark><head><meta charset=utf-8><meta name=viewport content="width=device-width"><meta name=theme-color content="#222" media="(prefers-color-scheme: dark)"><meta name=generator content="Hugo 0.111.3"><link rel="shortcut icon" type=image/x-icon href=/imgs/icons/favicon.ico><link rel=icon type=image/x-icon href=/imgs/icons/favicon.ico><link rel=icon type=image/png sizes=16x16 href=/imgs/icons/favicon_16x16.png><link rel=icon type=image/png sizes=32x32 href=/imgs/icons/favicon_32_32.png><link rel=apple-touch-icon sizes=180x180 href=/imgs/icons/apple_touch_icont.png><meta itemprop=name content="CSAPP Malloc Lab"><meta itemprop=description content="csapp malloc lab implementation"><meta itemprop=datePublished zgotmplz><meta itemprop=dateModified zgotmplz><meta itemprop=image content="https://izeroo.cn/imgs/avatar.jpg"><meta itemprop=keywords content="CSAPP,Malloc Lab"><meta property="og:type" content="article"><meta property="og:title" content="CSAPP Malloc Lab"><meta property="og:description" content="csapp malloc lab implementation"><meta property="og:image" content="/imgs/avatar.jpg"><meta property="og:image:width" content="312"><meta property="og:image:height" content="312"><meta property="og:image:type" content="image/jpeg/png/svg/jpg"><meta property="og:url" content="https://izeroo.cn/post/csapp-malloc-lab.html"><meta property="og:site_name" content="Zero's Record"><meta property="og:locale" content="zh-CN"><meta property="article:author" content="Zero"><meta property="article:published_time" content="2022-10-06 00:20:32 +0800 CST"><meta property="article:modified_time" content="2022-10-09 22:37:32 +0800 CST"><link type=text/css rel=stylesheet href=https://unpkg.com/@fortawesome/fontawesome-free@6.1.2/css/all.min.css><link type=text/css rel=stylesheet href=https://unpkg.com/animate.css@3.1.1/animate.min.css><link type=text/css rel=stylesheet href=https://unpkg.com/viewerjs@1.11.0/dist/viewer.min.css><link rel=stylesheet href=/css/main.min.fbdf2d7a7a7b64fd23bcb27e5c61762041e08c9eeb5a68d056f3b66bf87bd926.css><style type=text/css>.post-footer,.flinks-list-footer hr:after{content:"~ 我可是有底线的哟 ~"}</style><script type=text/javascript>(function(){localDB={set:function(e,t,n){if(n===0)return;const s=new Date,o=n*864e5,i={value:t,expiry:s.getTime()+o};localStorage.setItem(e,JSON.stringify(i))},get:function(e){const t=localStorage.getItem(e);if(!t)return void 0;const n=JSON.parse(t),s=new Date;return s.getTime()>n.expiry?(localStorage.removeItem(e),void 0):n.value}},theme={active:function(){const e=localDB.get("theme");if(e==null)return;theme.toggle(e),window.matchMedia("(prefers-color-scheme: dark)").addListener(function(e){theme.toggle(e.matches?"dark":"light")})},toggle:function(e){document.documentElement.setAttribute("data-theme",e),localDB.set("theme",e,2);const t=document.querySelector("iframe.giscus-frame");if(t){const n={setConfig:{theme:e}};t.contentWindow.postMessage({giscus:n},"https://giscus.app")}}},theme.active()})(window)</script><script class=next-config data-name=page type=application/json>{"comments":true,"isHome":false,"isPage":true,"path":"csapp-malloc-lab.html","permalink":"https://izeroo.cn/post/csapp-malloc-lab.html","title":"CSAPP Malloc Lab","waline":{"js":[{"alias":"waline","alias_name":"@waline/client","file":"dist/pageview.js","name":"pageview","version":"2.13.0"},{"alias":"waline","alias_name":"@waline/client","file":"dist/comment.js","name":"comment","version":"2.13.0"}]}}</script><script type=text/javascript>document.addEventListener("DOMContentLoaded",()=>{var e=document.createElement("script");e.charset="UTF-8",e.src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js",e.async=!1,e.defer=!0,document.head.appendChild(e),e.onload=function(){NexT.utils.fmtBusuanzi()}})</script><title>CSAPP Malloc Lab - Zero's Record</title><noscript><link rel=stylesheet href=/css/noscript.css></noscript></head><body itemscope itemtype=http://schema.org/WebPage class=use-motion><div class=headband></div><main class=main><header class=header itemscope itemtype=http://schema.org/WPHeader><div class=header-inner><div class=site-brand-container><div class=site-nav-toggle><div class=toggle aria-label role=button><span class=toggle-line></span>
<span class=toggle-line></span>
<span class=toggle-line></span></div></div><div class=site-meta><a href=/ class=brand rel=start><i class=logo-line></i><h1 class=site-title>Zero's Record</h1><i class=logo-line></i></a><p class=site-subtitle itemprop=description>记录值得记录的事情</p></div><div class=site-nav-right><div class="toggle popup-trigger"><i class="fa fa-search fa-fw fa-lg"></i></div></div></div><nav class=site-nav><ul class="main-menu menu"><li class="menu-item menu-item-home"><a href=/ class=hvr-icon-pulse rel=section><i class="fa fa-home hvr-icon"></i>首页</a></li><li class="menu-item menu-item-about"><a href=/about.html class=hvr-icon-pulse rel=section><i class="fa fa-user hvr-icon"></i>关于</a></li><li class="menu-item menu-item-archives"><a href=/archives/ class=hvr-icon-pulse rel=section><i class="fa fa-archive hvr-icon"></i>归档
<span class=badge>16</span></a></li><li class="menu-item menu-item-search"><a role=button class="popup-trigger hvr-icon-pulse"><i class="fa fa-search fa-fw hvr-icon"></i>搜索</a></li></ul></nav><div class=search-pop-overlay><div class="popup search-popup"><div class=search-header><span class=search-icon><i class="fa fa-search"></i></span><div class=search-input-container><input autocomplete=off autocapitalize=off maxlength=80 placeholder=搜索... spellcheck=false type=search class=search-input></div><span class=popup-btn-close role=button><i class="fa fa-times-circle"></i></span></div><div class="search-result-container no-result"><div class=search-result-icon><i class="fa fa-spinner fa-pulse fa-5x"></i></div></div></div></div></div><div class="toggle sidebar-toggle" role=button><span class=toggle-line></span>
<span class=toggle-line></span>
<span class=toggle-line></span></div><aside class=sidebar><div class="sidebar-inner sidebar-nav-active sidebar-toc-active"><ul class=sidebar-nav><li class=sidebar-nav-toc>文章目录</li><li class=sidebar-nav-overview>站点概览</li></ul><div class=sidebar-panel-container><div class="post-toc-wrap sidebar-panel"><div class="post-toc animated"><nav id=TableOfContents><ul><li><a href=#为什么要使用动态内存分配>为什么要使用动态内存分配</a></li><li><a href=#什么是动态内存分配器>什么是动态内存分配器</a><ul><li><a href=#函数定义>函数定义</a><ul><li><a href=#malloc>malloc</a></li><li><a href=#sbrk>sbrk</a></li><li><a href=#free>free</a></li></ul></li></ul></li><li><a href=#分配器的实现>分配器的实现</a><ul><li><a href=#实现一implicit-free-list隐式空闲链表>实现一：Implicit Free List（隐式空闲链表）</a><ul><li><a href=#如何保存内存块的信息>如何保存内存块的信息？</a></li><li><a href=#如何放置有效负载到空闲块>如何放置有效负载到空闲块？</a></li><li><a href=#如何分割空闲块>如何分割空闲块？</a></li><li><a href=#如何合并内存块>如何合并内存块？</a></li><li><a href=#分配器设计>分配器设计</a></li><li><a href=#实现代码>实现代码</a></li><li><a href=#去掉分配块的footer的实现代码>去掉分配块的Footer的实现代码</a></li></ul></li><li><a href=#实现二explicit-free-list显示空闲链表>实现二：Explicit Free List（显示空闲链表）</a><ul><li><a href=#如何保存内存块的信息-1>如何保存内存块的信息？</a></li><li><a href=#堆块的放置合并分割>堆块的放置、合并、分割</a></li><li><a href=#分配器设计-1>分配器设计</a></li><li><a href=#实现代码-1>实现代码</a></li></ul></li><li><a href=#实现三segregated-free-list分离式空闲链表>实现三：Segregated Free List（分离式空闲链表）</a><ul><li><a href=#实现代码-2>实现代码</a></li></ul></li></ul></li></ul></nav></div></div><div class="site-overview-wrap sidebar-panel"><div class="site-author site-overview-item animated" itemprop=author itemscope itemtype=http://schema.org/Person><img class=site-author-image itemprop=image alt=Zero src=/imgs/img-lazy-loading.gif data-src=/imgs/avatar.jpg><p class=site-author-name itemprop=name>Zero</p><div class=site-description itemprop=description>...</div></div><div class="site-state-wrap site-overview-item animated"><nav class=site-state><div class="site-state-item site-state-posts"><a href=/archives/><span class=site-state-item-count>16</span>
<span class=site-state-item-name>日志</span></a></div><div class="site-state-item site-state-categories"><a href=/categories/><span class=site-state-item-count>6</span>
<span class=site-state-item-name>分类</span></a></div><div class="site-state-item site-state-tags"><a href=/tags/><span class=site-state-item-count>18</span>
<span class=site-state-item-name>标签</span></a></div></nav></div><div class="links-of-social site-overview-item animated"><span class=links-of-social-item><a href=https://github.com/izeroo title="Github → https://github.com/izeroo" rel=noopener class=hvr-icon-pulse target=_blank><i class="fab fa-github fa-fw hvr-icon"></i>
Github</a></span></div><div class="cc-license animated" itemprop=license><a href=https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh class=cc-opacity rel=noopener target=_blank title=共享知识><img src=/imgs/img-lazy-loading.gif data-src=/imgs/cc/big/by_nc_sa.svg alt=共享知识></a></div><div class="links-of-blogroll site-overview-item animated"><div class=links-of-blogroll-title><i class="fa fa-globe fa-fw"></i>
友情链接</div><ul class=links-of-blogroll-list><li class=links-of-blogroll-item><a href=https://gitee.com/hugo-next/hugo-theme-next title=https://gitee.com/hugo-next/hugo-theme-next target=_blank>Hugo-NexT</a></li><li class=links-of-blogroll-item><a href=https://lisenhui.cn title=https://lisenhui.cn target=_blank>凡梦星尘空间站</a></li><li class=links-of-blogroll-item><a href=https://lemono.fun title=https://lemono.fun target=_blank>Lemono</a></li><li class=links-of-blogroll-item><a href=http://yuno0n.top title=http://yuno0n.top target=_blank>Yunoon</a></li><li class=links-of-blogroll-item><a href=https://momoe.ml title=https://momoe.ml target=_blank>Zy143L</a></li><li class=links-of-blogroll-item><a href=https://9bingyin.com title=https://9bingyin.com target=_blank>Bingyin</a></li><li class=links-of-blogroll-item><a href=https://www.tangrr.top title=https://www.tangrr.top target=_blank>皮皮</a></li></ul></div></div></div></div><div id=siteinfo-card-widget class=sidebar-card-widget><div class=item-headline><i class="fas fa-chart-line"></i>
<span>网站资讯</span></div><div class=siteinfo><div class=siteinfo-item><div class=item-name><i class="fa-solid fa-calendar-check"></i>已运行：</div><div class=item-count id=runTimes data-publishdate=2018-08-27T17:32:11+08:00></div></div><div class=siteinfo-item><div class=item-name><i class="fas fa fa-user"></i>总访客数：</div><div class=item-count id=busuanzi_value_site_uv><i class="fa fa-sync fa-spin"></i></div></div><div class=siteinfo-item><div class=item-name><i class="fas fa fa-eye"></i>页面浏览：</div><div class=item-count id=busuanzi_value_site_pv><i class="fa fa-sync fa-spin"></i></div></div><div class=siteinfo-item><div class=item-name><i class="fa fa-font"></i>总字数：</div><div class=item-count id=wordsCount data-count=28833></div></div><div class=siteinfo-item><div class=item-name><i class="fa fa-mug-hot"></i>阅读约：</div><div class=item-count id=readTimes data-times=67></div></div><div class=siteinfo-item><div class=item-name><i class="fa fa-clock-rotate-left"></i>最后更新于：</div><div class=item-count id=last-push-date data-lastpushdate=2023-11-14T22:56:00+08:00></div></div></div></div></aside><div class=sidebar-dimmer></div></header><div class=tool-buttons><div id=goto-comments class="button goto-comments" title=直达评论><i class="fas fa-comments"></i></div><div id=toggle-theme class=button title=深浅模式切换><i class="fas fa-adjust"></i></div><div class=back-to-top role=button title=返回顶部><i class="fa fa-arrow-up"></i>
<span>0%</span></div></div><div class=reading-progress-bar></div><noscript><div class=noscript-warning>Theme NexT works best with JavaScript enabled</div></noscript><div class="main-inner post posts-expand"><div class=post-block><article itemscope itemtype=http://schema.org/Article class=post-content lang><link itemprop=mainEntityOfPage href=https://izeroo.cn/post/csapp-malloc-lab.html><span hidden itemprop=author itemscope itemtype=http://schema.org/Person><meta itemprop=image content="/imgs/avatar.jpg"><meta itemprop=name content="Zero"></span><span hidden itemprop=publisher itemscope itemtype=http://schema.org/Organization><meta itemprop=name content="Zero"><meta itemprop=description content="..."></span><span hidden itemprop=post itemscope itemtype=http://schema.org/CreativeWork><meta itemprop=name content="CSAPP Malloc Lab"><meta itemprop=description content="csapp malloc lab implementation"></span><header class=post-header><h1 class=post-title itemprop="name headline">CSAPP Malloc Lab</h1><div class=post-meta-container><div class=post-meta-items><span class=post-meta-item><span class=post-meta-item-icon><i class="far fa-calendar"></i></span>
<span class=post-meta-item-text title=发表于>发表于：</span>
<time title="创建时间：2022-10-06 00:20:32 +0800 CST" itemprop="dateCreated datePublished" datetime="2022-10-06 00:20:32 +0800 CST">2022-10-06</time></span>
<span class=post-meta-item><span class=post-meta-item-icon><i class="far fa-calendar-check"></i></span>
<span class=post-meta-item-text title=更新于>更新于：</span>
<time title=修改时间：2022-10-09T22:37:32+08:00 itemprop=dateModified datetime=2022-10-09T22:37:32+08:00>2022-10-09</time></span>
<span class=post-meta-item><span class=post-meta-item-icon><i class="far fa-folder-open"></i></span>
<span class=post-meta-item-text title=分类于>分类于：</span>
<span itemprop=about itemscope itemtype=http://schema.org/Thing><a href=/categories/%E6%8A%80%E6%9C%AF itemprop=url rel=index><span itemprop=name>技术</span></a></span></span></div><div class=post-meta-items><span class=post-meta-item title=字数><span class=post-meta-item-icon><i class="far fa-file-word"></i></span>
<span class=post-meta-item-text>字数：</span>
<span>10044</span></span>
<span class=post-meta-item title=阅读><span class=post-meta-item-icon><i class="far fa-clock"></i></span>
<span class=post-meta-item-text>阅读：&ap;</span>
<span>21分钟</span></span>
<span class=post-meta-item title=浏览><span class=post-meta-item-icon><i class="far fa-eye"></i></span>
<span class=post-meta-item-text>浏览：</span>
<span id=busuanzi_value_page_pv data-path=/post/csapp-malloc-lab.html><i class="fa fa-sync fa-spin"></i></span></span>
<span class=post-meta-item title><span class=post-meta-item-icon><i class="far fa-comments"></i></span>
<span class=post-meta-item-text title=评论>评论：</span>
<span id=comments-count class=waline-comment-count data-path=/post/csapp-malloc-lab.html><i class="fa fa-sync fa-spin"></i></span></span></div></div></header><div class="post-body autonumber" itemprop=articleBody><p>最近准备研究堆题，于是打算把 CSAPP 的 malloc lab 给完成了，记录一下知识点。</p><h2 id=为什么要使用动态内存分配>为什么要使用动态内存分配
<a class=header-anchor href=#%e4%b8%ba%e4%bb%80%e4%b9%88%e8%a6%81%e4%bd%bf%e7%94%a8%e5%8a%a8%e6%80%81%e5%86%85%e5%ad%98%e5%88%86%e9%85%8d></a></h2><p>虽然可以使用低级的 mmap 和 munmap 函数来创建和删除虚拟内存的区域，但是当程序运行时需要额外虚拟内存时，用动态内存分配器（dynamic memory allocator)更方便，也有更好的可移植性。</p><h2 id=什么是动态内存分配器>什么是动态内存分配器
<a class=header-anchor href=#%e4%bb%80%e4%b9%88%e6%98%af%e5%8a%a8%e6%80%81%e5%86%85%e5%ad%98%e5%88%86%e9%85%8d%e5%99%a8></a></h2><p>动态内存分配器维护着一个进程的虚拟内存区域，称为堆（heap）（见下图）。它紧接在未初始化的数据区域（.bss段）后开始，并向高地址增长。 对于每个进程，内核维护着一个变量 brk，它指向堆的顶部。</p><p><img src=/imgs/img-lazy-loading.gif data-src=image-20221006162435244.png alt=image-20221006162435244></p><p>分配器将堆视为一组不同大小的块（block）的集合来维护。每个块都是一块连续的虚拟内存，要么是已分配的，要么是空闲的。已分配的块显式地保留为供应用程序使用。空闲块保持空闲，直到它显式地被应用所分配。一个已分配的块保持已分配状态，直到它被释放。</p><h3 id=函数定义>函数定义
<a class=header-anchor href=#%e5%87%bd%e6%95%b0%e5%ae%9a%e4%b9%89></a></h3><h4 id=malloc>malloc
<a class=header-anchor href=#malloc></a></h4><p>C 标准库提供了一个函数名为 malloc 显式内存分配器。程序通过调用 malloc 函数来从堆中分配块。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=display:flex><span><span style=color:#75715e>#include</span> <span style=color:#75715e>&lt;stdlib.h&gt;</span><span style=color:#75715e>
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>
</span></span><span style=display:flex><span><span style=color:#75715e>/* 返回值:若成功则返回已分配块的指针，出错返回 NULL */</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>void</span> <span style=color:#f92672>*</span><span style=color:#a6e22e>malloc</span>(<span style=color:#66d9ef>size_t</span> size);
</span></span></code></pre></div><p>malloc 函数返回一个指针，指向大小为至少 size 字节的内存块，这个块会为可能包含在这个块内的任何数据对象类型做对齐。实际中，对齐依赖于编译代码在 32 位模式（gcc -m32）还是 64 位模式中运行。在 32 位模式中，malloc 返回的块的地址总是 8 的倍数。在 64 位模式中，该地址总是 16 的倍数。</p><h4 id=sbrk>sbrk
<a class=header-anchor href=#sbrk></a></h4><p>sbrk 函数通过将内核的 brk 指针增加 incr 来扩展和收缩堆。如果成功，它就返回brk 的旧值，否则，它就返回 -1，并将 errono 设置为 ENOMEM
，如果 incr 为零， sbrk 就返回 brk 的当前值。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=display:flex><span><span style=color:#75715e>#include</span> <span style=color:#75715e>&lt;stdlib.h&gt;</span><span style=color:#75715e>
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#75715e>/* 返回值：若成功则为旧的brk指针，出错返回 -1 */</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>void</span> <span style=color:#f92672>*</span><span style=color:#a6e22e>sbrk</span>(<span style=color:#66d9ef>intptr_t</span> incr);
</span></span></code></pre></div><h4 id=free>free
<a class=header-anchor href=#free></a></h4><p>程序通过调用 free 函数来释放已分配的堆块。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=display:flex><span><span style=color:#75715e>#include</span> <span style=color:#75715e>&lt;stdlib.h&gt;</span><span style=color:#75715e>
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#66d9ef>void</span> <span style=color:#a6e22e>free</span>(<span style=color:#66d9ef>void</span> <span style=color:#f92672>*</span>ptr);
</span></span></code></pre></div><p>ptr 参数必须指向一个从 malloc、calloc 或者 realloc 获得的已分配块的起始位置。如果不是，那么 free 的行为就是未定义的。更糟的是，既然它什么都不返回，free就不会告诉应用出现了错误。</p><h2 id=分配器的实现>分配器的实现
<a class=header-anchor href=#%e5%88%86%e9%85%8d%e5%99%a8%e7%9a%84%e5%ae%9e%e7%8e%b0></a></h2><h3 id=实现一implicit-free-list隐式空闲链表>实现一：Implicit Free List（隐式空闲链表）
<a class=header-anchor href=#%e5%ae%9e%e7%8e%b0%e4%b8%80implicit-free-list%e9%9a%90%e5%bc%8f%e7%a9%ba%e9%97%b2%e9%93%be%e8%a1%a8></a></h3><h4 id=如何保存内存块的信息>如何保存内存块的信息？
<a class=header-anchor href=#%e5%a6%82%e4%bd%95%e4%bf%9d%e5%ad%98%e5%86%85%e5%ad%98%e5%9d%97%e7%9a%84%e4%bf%a1%e6%81%af></a></h4><p>任何实际的分配器都需要一些数据结构，允许它来区别块边界，以及区别已分配块和空闲块。大多数分配器将这些信息嵌入块本身。一个简单的方法如下图所示。</p><p><img src=/imgs/img-lazy-loading.gif data-src=image-20221006164035042.png alt=image-20221006164035042></p><p>在这种情况中，一个块是由一个字的头部（header）、有效载荷（payload），以及可能的一些额外的填充（padding）组成的。头部编码了这个块的大小（包括头部和所有的填充），以及这个块是已分配的还是空闲的。</p><p>由于对齐的要求，块大小必须是 8 或 16 的整数倍，因此我们可以巧妙地利用块大小的低位来保存块的分配情况。</p><p>上面这种数据结构有一个问题，合并空闲内存块时无法直接找到它的上一个内存块，需要从堆的开始进行遍历。Knuth 提出了一种叫边界标记的技术：每个块的结尾添加一个 footer（头部的副本），这样就可以通过头部的地址减去头部的大小定位到上一个块的 footer 从而得知上一个块的信息了。</p><h4 id=如何放置有效负载到空闲块>如何放置有效负载到空闲块？
<a class=header-anchor href=#%e5%a6%82%e4%bd%95%e6%94%be%e7%bd%ae%e6%9c%89%e6%95%88%e8%b4%9f%e8%bd%bd%e5%88%b0%e7%a9%ba%e9%97%b2%e5%9d%97></a></h4><p>当一个应用请求一个 k 字节的块（payload）时，分配器需要搜索空闲链表，查找一个大小可以满足请求的空闲块。</p><p>分配器如何搜索空闲块有多种方式，被称为<strong>放置策略</strong>（placement policy）。常见的适配策略有首次适配（first fit)、下一次适配（next fit)和最佳适配（best fit)。</p><p>首次适配从头开始搜索空闲链表，选择第一个合适的空闲块。下一次适配和首次适配很相似，只不过不是从链表的起始处开始每次搜索，而是从上一次査询结束的地方开始。最佳适配检査每个空闲块，选择适合所需请求大小的最小空闲块。首次适配的优点是它趋向于将大的空闲块保留在链表的后面。缺点是它趋向于在靠近
链表起始处留下小空闲块的“碎片”，这就增加了对较大块的搜索时间。下一次适配是由Donald Knuth 作为首次适配的一种代替品最早提出的，源于这样一个想法：如果我们上一次在某个空闲块里已经发现了一个匹配，那么很可能下一次我们也能在这个剩余块中发现匹配。下一次适配比首次适配运行起来明显要快一些，尤其是当链表的前面布满了许多小的碎片时。然而，一些研究表明，下一次适配的内存利用率要比首次适配低得多。研究还表明最佳适配比首次适配和下一次适配的内存利用率都要高一些。然而，在简单空闲链表组织结构中，比如隐式空闲链表中，使用最佳适配的缺点是它要求对堆进行彻底的搜索。在后面，我们将看到更加精细复杂的分离式空闲链表组织，它接近于最佳适配策略，不需要进行彻底的堆搜索。</p><h4 id=如何分割空闲块>如何分割空闲块？
<a class=header-anchor href=#%e5%a6%82%e4%bd%95%e5%88%86%e5%89%b2%e7%a9%ba%e9%97%b2%e5%9d%97></a></h4><p>如果内存分配器搜索到的空闲块要比请求（payload）的大小大得多，以至于可以把空闲块分割成两个块，那么分配器就要考虑是否要进行分割，否则会造成内存空间的浪费。</p><p>由于对齐的需要以及需要记录内存块的信息，实际上最小的 payload 大小是有限制的。footer 和 header 各占 4 字节，payload 的大小最小必须为 8 字节来保证内存对齐。</p><h4 id=如何合并内存块>如何合并内存块？
<a class=header-anchor href=#%e5%a6%82%e4%bd%95%e5%90%88%e5%b9%b6%e5%86%85%e5%ad%98%e5%9d%97></a></h4><p>有 4 种可能的情况，见下图。</p><p><img src=/imgs/img-lazy-loading.gif data-src=image-20221006170636229.png alt=image-20221006170636229></p><h4 id=分配器设计>分配器设计
<a class=header-anchor href=#%e5%88%86%e9%85%8d%e5%99%a8%e8%ae%be%e8%ae%a1></a></h4><p>mem_init调用mem_sbrk(4*WSIZE)将堆扩大到 16 Bytes，起始一个 WSIZE 的空间用于对齐，后续3个 WSIZE 用于设置序言块和结尾块，序言块只有 header 和 footer，内容都是 8/1。结尾块的内容是 0/1 。 然后将 head_listp 指向序言块的 footer（相当于指向 payload）。序言块和结尾块不修改，这样做为合并空闲块和遍历堆块提供了方便。链表的形式如下</p><p><img src=/imgs/img-lazy-loading.gif data-src=image-20221006182237824.png alt=image-20221006182237824></p><h4 id=实现代码>实现代码
<a class=header-anchor href=#%e5%ae%9e%e7%8e%b0%e4%bb%a3%e7%a0%81></a></h4><p>实现了first Fit和 next fit，next fit得分更高， 跑出了 83 / 100 的成绩</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-fallback data-lang=fallback><span style=display:flex><span>Results for mm malloc:
</span></span><span style=display:flex><span>trace  valid  util     ops      secs  Kops
</span></span><span style=display:flex><span> 0       yes   91%    5694  0.001076  5293
</span></span><span style=display:flex><span> 1       yes   91%    5848  0.000707  8276
</span></span><span style=display:flex><span> 2       yes   95%    6648  0.001988  3344
</span></span><span style=display:flex><span> 3       yes   97%    5380  0.001947  2763
</span></span><span style=display:flex><span> 4       yes   66%   14400  0.000087164948
</span></span><span style=display:flex><span> 5       yes   90%    4800  0.003151  1523
</span></span><span style=display:flex><span> 6       yes   88%    4800  0.002977  1613
</span></span><span style=display:flex><span> 7       yes   55%   12000  0.007354  1632
</span></span><span style=display:flex><span> 8       yes   51%   24000  0.004272  5618
</span></span><span style=display:flex><span> 9       yes   27%   14401  0.031505   457
</span></span><span style=display:flex><span>10       yes   45%   14401  0.001722  8362
</span></span><span style=display:flex><span>Total          72%  112372  0.056786  1979
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>Perf index = 43 (util) + 40 (thru) = 83/100
</span></span></code></pre></div><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=display:flex><span><span style=color:#75715e>/*
</span></span></span><span style=display:flex><span><span style=color:#75715e> * mm-implicit-list.c - Plain malloc package using implicit list.
</span></span></span><span style=display:flex><span><span style=color:#75715e> *                      Fit strategy: next fit.
</span></span></span><span style=display:flex><span><span style=color:#75715e> */</span>
</span></span><span style=display:flex><span><span style=color:#75715e>#include</span> <span style=color:#75715e>&lt;stdio.h&gt;</span><span style=color:#75715e>
</span></span></span><span style=display:flex><span><span style=color:#75715e>#include</span> <span style=color:#75715e>&lt;stdlib.h&gt;</span><span style=color:#75715e>
</span></span></span><span style=display:flex><span><span style=color:#75715e>#include</span> <span style=color:#75715e>&lt;assert.h&gt;</span><span style=color:#75715e>
</span></span></span><span style=display:flex><span><span style=color:#75715e>#include</span> <span style=color:#75715e>&lt;unistd.h&gt;</span><span style=color:#75715e>
</span></span></span><span style=display:flex><span><span style=color:#75715e>#include</span> <span style=color:#75715e>&lt;string.h&gt;</span><span style=color:#75715e>
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>
</span></span><span style=display:flex><span><span style=color:#75715e>#include</span> <span style=color:#75715e>&#34;mm.h&#34;</span><span style=color:#75715e>
</span></span></span><span style=display:flex><span><span style=color:#75715e>#include</span> <span style=color:#75715e>&#34;memlib.h&#34;</span><span style=color:#75715e>
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>
</span></span><span style=display:flex><span><span style=color:#75715e>/*********************************************************
</span></span></span><span style=display:flex><span><span style=color:#75715e> * NOTE TO STUDENTS: Before you do anything else, please
</span></span></span><span style=display:flex><span><span style=color:#75715e> * provide your team information in the following struct.
</span></span></span><span style=display:flex><span><span style=color:#75715e> ********************************************************/</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>team_t</span> team <span style=color:#f92672>=</span> {
</span></span><span style=display:flex><span>    <span style=color:#75715e>/* Team name */</span>
</span></span><span style=display:flex><span>    <span style=color:#e6db74>&#34;ateam&#34;</span>,
</span></span><span style=display:flex><span>    <span style=color:#75715e>/* First member&#39;s full name */</span>
</span></span><span style=display:flex><span>    <span style=color:#e6db74>&#34;Harry Bovik&#34;</span>,
</span></span><span style=display:flex><span>    <span style=color:#75715e>/* First member&#39;s email address */</span>
</span></span><span style=display:flex><span>    <span style=color:#e6db74>&#34;bovik@cs.cmu.edu&#34;</span>,
</span></span><span style=display:flex><span>    <span style=color:#75715e>/* Second member&#39;s full name (leave blank if none) */</span>
</span></span><span style=display:flex><span>    <span style=color:#e6db74>&#34;&#34;</span>,
</span></span><span style=display:flex><span>    <span style=color:#75715e>/* Second member&#39;s email address (leave blank if none) */</span>
</span></span><span style=display:flex><span>    <span style=color:#e6db74>&#34;&#34;</span>
</span></span><span style=display:flex><span>};
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>/* 8 bytes alignment in 32bit mode */</span>
</span></span><span style=display:flex><span><span style=color:#75715e>#define ALIGNMENT 8
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>
</span></span><span style=display:flex><span><span style=color:#75715e>/* Rounds up to the nearest multiple of ALIGNMENT */</span>
</span></span><span style=display:flex><span><span style=color:#75715e>#define ALIGN(size) (((size) + (ALIGNMENT-1)) &amp; ~0x7)
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>
</span></span><span style=display:flex><span><span style=color:#75715e>//* Basic constants and macros: */
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#75715e>#define WSIZE      4          </span><span style=color:#75715e>/* Word and header/footer size (bytes) */</span><span style=color:#75715e>
</span></span></span><span style=display:flex><span><span style=color:#75715e>#define DSIZE      8          </span><span style=color:#75715e>/* Doubleword size (bytes) */</span><span style=color:#75715e>
</span></span></span><span style=display:flex><span><span style=color:#75715e>#define CHUNKSIZE  (1&lt;&lt;12)    </span><span style=color:#75715e>/* Extend heap by this amount (bytes) */</span><span style=color:#75715e>
</span></span></span><span style=display:flex><span><span style=color:#75715e>#define MINBLOCKSIZE 16
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>
</span></span><span style=display:flex><span><span style=color:#75715e>/* Max value of 2 values */</span>
</span></span><span style=display:flex><span><span style=color:#75715e>#define MAX(x, y) ((x) &gt; (y) ? (x) : (y))
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>
</span></span><span style=display:flex><span><span style=color:#75715e>/* Pack a size and allocated bit into a word */</span>
</span></span><span style=display:flex><span><span style=color:#75715e>#define PACK(size, alloc)  ((size) | (alloc))
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>
</span></span><span style=display:flex><span><span style=color:#75715e>/* Read and write a word at address p. */</span>
</span></span><span style=display:flex><span><span style=color:#75715e>#define GET(p)       (*(unsigned int *)(p))
</span></span></span><span style=display:flex><span><span style=color:#75715e>#define PUT(p, val)  (*(unsigned int *)(p) = (val))
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>
</span></span><span style=display:flex><span><span style=color:#75715e>/* Read the size and allocated fields from address p */</span>
</span></span><span style=display:flex><span><span style=color:#75715e>#define GET_SIZE(p)   (GET(p) &amp; ~0x7) </span><span style=color:#75715e>/* Take attention!!! size = header + payload + footer */</span><span style=color:#75715e>
</span></span></span><span style=display:flex><span><span style=color:#75715e>#define GET_ALLOC(p)  (GET(p) &amp; 0x1)
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>
</span></span><span style=display:flex><span><span style=color:#75715e>/* Given block ptr bp, compute address of its header and footer */</span>
</span></span><span style=display:flex><span><span style=color:#75715e>#define HDRP(bp)  ((char *)(bp) - WSIZE)
</span></span></span><span style=display:flex><span><span style=color:#75715e>#define FTRP(bp)  ((char *)(bp) + GET_SIZE(HDRP(bp)) - DSIZE)
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>
</span></span><span style=display:flex><span><span style=color:#75715e>/* Given block ptr bp, compute address of next and previous blocks */</span>
</span></span><span style=display:flex><span><span style=color:#75715e>#define NEXT_BLKP(bp)  ((char *)(bp) + GET_SIZE(HDRP(bp)))
</span></span></span><span style=display:flex><span><span style=color:#75715e>#define PREV_BLKP(bp)  ((char *)(bp) - GET_SIZE((char *)(bp) - DSIZE))
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>
</span></span><span style=display:flex><span><span style=color:#75715e>/* Global declarations */</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>static</span> <span style=color:#66d9ef>char</span> <span style=color:#f92672>*</span>heap_listp, <span style=color:#f92672>*</span>prev_listp;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>/* Function prototypes for internal helper routines */</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>static</span> <span style=color:#66d9ef>void</span> <span style=color:#f92672>*</span><span style=color:#a6e22e>coalesce</span>(<span style=color:#66d9ef>void</span> <span style=color:#f92672>*</span>bp);
</span></span><span style=display:flex><span><span style=color:#66d9ef>static</span> <span style=color:#66d9ef>void</span> <span style=color:#f92672>*</span><span style=color:#a6e22e>extend_heap</span>(<span style=color:#66d9ef>size_t</span> words);
</span></span><span style=display:flex><span><span style=color:#66d9ef>static</span> <span style=color:#66d9ef>void</span> <span style=color:#f92672>*</span><span style=color:#a6e22e>find_fit</span>(<span style=color:#66d9ef>size_t</span> asize);
</span></span><span style=display:flex><span><span style=color:#66d9ef>static</span> <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>place</span>(<span style=color:#66d9ef>void</span> <span style=color:#f92672>*</span>bp, <span style=color:#66d9ef>size_t</span> asize);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>/* 
</span></span></span><span style=display:flex><span><span style=color:#75715e> * mm_init - initialize the malloc package.
</span></span></span><span style=display:flex><span><span style=color:#75715e> */</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>int</span> <span style=color:#a6e22e>mm_init</span>(<span style=color:#66d9ef>void</span>)
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>    <span style=color:#75715e>/* Create the initial empty heap */</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> ((heap_listp <span style=color:#f92672>=</span> <span style=color:#a6e22e>mem_sbrk</span>(<span style=color:#ae81ff>4</span><span style=color:#f92672>*</span>WSIZE)) <span style=color:#f92672>==</span> (<span style=color:#66d9ef>void</span> <span style=color:#f92672>*</span>) <span style=color:#f92672>-</span><span style=color:#ae81ff>1</span>)
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> <span style=color:#f92672>-</span><span style=color:#ae81ff>1</span>;
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>PUT</span>(heap_listp, <span style=color:#ae81ff>0</span>);                             <span style=color:#75715e>/* alignment padding */</span>
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>PUT</span>(heap_listp <span style=color:#f92672>+</span> (<span style=color:#ae81ff>1</span><span style=color:#f92672>*</span>WSIZE), <span style=color:#a6e22e>PACK</span>(DSIZE, <span style=color:#ae81ff>1</span>));    <span style=color:#75715e>/* Prologue header */</span>
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>PUT</span>(heap_listp <span style=color:#f92672>+</span> (<span style=color:#ae81ff>2</span><span style=color:#f92672>*</span>WSIZE), <span style=color:#a6e22e>PACK</span>(DSIZE, <span style=color:#ae81ff>1</span>));    <span style=color:#75715e>/* Prologue footer */</span>
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>PUT</span>(heap_listp <span style=color:#f92672>+</span> (<span style=color:#ae81ff>3</span><span style=color:#f92672>*</span>WSIZE), <span style=color:#a6e22e>PACK</span>(DSIZE, <span style=color:#ae81ff>1</span>));    <span style=color:#75715e>/* Epilogue header */</span>
</span></span><span style=display:flex><span>    heap_listp <span style=color:#f92672>+=</span> (<span style=color:#ae81ff>2</span><span style=color:#f92672>*</span>WSIZE);    <span style=color:#75715e>/* make heap_listp points to epilogue header */</span>
</span></span><span style=display:flex><span>    prev_listp <span style=color:#f92672>=</span> heap_listp;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>/* Extend the empty heap with a free block of CHUNKSIZE bytes */</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> (<span style=color:#a6e22e>extend_heap</span>(CHUNKSIZE<span style=color:#f92672>/</span>WSIZE) <span style=color:#f92672>==</span> NULL)
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> <span style=color:#f92672>-</span><span style=color:#ae81ff>1</span>;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> <span style=color:#ae81ff>0</span>;
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>/* 
</span></span></span><span style=display:flex><span><span style=color:#75715e> * mm_malloc - Allocate a block by incrementing the brk pointer.
</span></span></span><span style=display:flex><span><span style=color:#75715e> *             Always allocate a block whose size is a multiple of the alignment.
</span></span></span><span style=display:flex><span><span style=color:#75715e> */</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>void</span> <span style=color:#f92672>*</span><span style=color:#a6e22e>mm_malloc</span>(<span style=color:#66d9ef>size_t</span> size)
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>size_t</span> asize; <span style=color:#75715e>/* Adjusted block size */</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>size_t</span> extendsize; <span style=color:#75715e>/* Amount to extend heap if not fit */</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>char</span> <span style=color:#f92672>*</span>bp;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>/* Ignore spurious requests */</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> (size <span style=color:#f92672>==</span> <span style=color:#ae81ff>0</span>) {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> NULL;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>/* Adjust block size to include overhead and alignment reqs */</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> (size <span style=color:#f92672>&lt;</span> DSIZE)
</span></span><span style=display:flex><span>        asize <span style=color:#f92672>=</span> <span style=color:#ae81ff>2</span> <span style=color:#f92672>*</span> DSIZE; <span style=color:#75715e>/* Minimum block size: WORD(HDR) + DWORD(Payload) + WORD(FTR) */</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>else</span>
</span></span><span style=display:flex><span>        asize <span style=color:#f92672>=</span> <span style=color:#a6e22e>ALIGN</span>(size <span style=color:#f92672>+</span> <span style=color:#ae81ff>8</span>);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>/* Search the free list for a fit */</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> ((bp <span style=color:#f92672>=</span> <span style=color:#a6e22e>find_fit</span>(asize)) <span style=color:#f92672>!=</span> NULL) {
</span></span><span style=display:flex><span>        <span style=color:#a6e22e>place</span>(bp, asize);
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> bp;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>/* No fit. Get more memory and place the block */</span>
</span></span><span style=display:flex><span>    extendsize <span style=color:#f92672>=</span> <span style=color:#a6e22e>MAX</span>(asize, CHUNKSIZE);
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> ((bp <span style=color:#f92672>=</span> <span style=color:#a6e22e>extend_heap</span>(extendsize <span style=color:#f92672>/</span> WSIZE)) <span style=color:#f92672>==</span> NULL)
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> NULL;
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>place</span>(bp, asize);
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> bp;
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>/*
</span></span></span><span style=display:flex><span><span style=color:#75715e> * mm_free - Freeing a block and coalesce if necessary.
</span></span></span><span style=display:flex><span><span style=color:#75715e> */</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>void</span> <span style=color:#a6e22e>mm_free</span>(<span style=color:#66d9ef>void</span> <span style=color:#f92672>*</span>bp)
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>size_t</span> size <span style=color:#f92672>=</span> <span style=color:#a6e22e>GET_SIZE</span>(<span style=color:#a6e22e>HDRP</span>(bp));
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>PUT</span>(<span style=color:#a6e22e>HDRP</span>(bp), <span style=color:#a6e22e>PACK</span>(size, <span style=color:#ae81ff>0</span>));
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>PUT</span>(<span style=color:#a6e22e>FTRP</span>(bp), <span style=color:#a6e22e>PACK</span>(size, <span style=color:#ae81ff>0</span>));
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>coalesce</span>(bp);
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>/*
</span></span></span><span style=display:flex><span><span style=color:#75715e> * mm_realloc - Implemented simply in terms of mm_malloc and mm_free
</span></span></span><span style=display:flex><span><span style=color:#75715e> */</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>void</span> <span style=color:#f92672>*</span><span style=color:#a6e22e>mm_realloc</span>(<span style=color:#66d9ef>void</span> <span style=color:#f92672>*</span>ptr, <span style=color:#66d9ef>size_t</span> size)
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>void</span> <span style=color:#f92672>*</span>oldptr <span style=color:#f92672>=</span> ptr;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>void</span> <span style=color:#f92672>*</span>newptr;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>size_t</span> copySize;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    newptr <span style=color:#f92672>=</span> <span style=color:#a6e22e>mm_malloc</span>(size);
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> (newptr <span style=color:#f92672>==</span> NULL)
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> NULL;
</span></span><span style=display:flex><span>    size <span style=color:#f92672>=</span> <span style=color:#a6e22e>GET_SIZE</span>(<span style=color:#a6e22e>HDRP</span>(oldptr));
</span></span><span style=display:flex><span>    copySize <span style=color:#f92672>=</span> <span style=color:#a6e22e>GET_SIZE</span>(<span style=color:#a6e22e>HDRP</span>(newptr));
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> (size <span style=color:#f92672>&lt;</span> copySize)
</span></span><span style=display:flex><span>        copySize <span style=color:#f92672>=</span> size;
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>memcpy</span>(newptr, oldptr, copySize<span style=color:#f92672>-</span>WSIZE);
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>mm_free</span>(oldptr);
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> newptr;
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>/*
</span></span></span><span style=display:flex><span><span style=color:#75715e> * coalesce - Merge freed block.
</span></span></span><span style=display:flex><span><span style=color:#75715e> */</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>static</span> <span style=color:#66d9ef>void</span><span style=color:#f92672>*</span> <span style=color:#a6e22e>coalesce</span>(<span style=color:#66d9ef>void</span><span style=color:#f92672>*</span> bp)
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>size_t</span> prev_alloc <span style=color:#f92672>=</span> <span style=color:#a6e22e>GET_ALLOC</span>(<span style=color:#a6e22e>HDRP</span>(<span style=color:#a6e22e>PREV_BLKP</span>(bp)));
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>size_t</span> next_alloc <span style=color:#f92672>=</span> <span style=color:#a6e22e>GET_ALLOC</span>(<span style=color:#a6e22e>HDRP</span>(<span style=color:#a6e22e>NEXT_BLKP</span>(bp)));
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>size_t</span> size <span style=color:#f92672>=</span> <span style=color:#a6e22e>GET_SIZE</span>(<span style=color:#a6e22e>HDRP</span>(bp));
</span></span><span style=display:flex><span>    
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> (prev_alloc <span style=color:#f92672>&amp;&amp;</span> next_alloc)
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> bp;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>else</span> <span style=color:#66d9ef>if</span> (prev_alloc <span style=color:#f92672>&amp;&amp;</span> <span style=color:#f92672>!</span>next_alloc) {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span> (<span style=color:#a6e22e>NEXT_BLKP</span>(bp) <span style=color:#f92672>==</span> prev_listp)
</span></span><span style=display:flex><span>            prev_listp <span style=color:#f92672>=</span> bp;
</span></span><span style=display:flex><span>        size <span style=color:#f92672>+=</span> <span style=color:#a6e22e>GET_SIZE</span>(<span style=color:#a6e22e>HDRP</span>(<span style=color:#a6e22e>NEXT_BLKP</span>(bp)));
</span></span><span style=display:flex><span>        <span style=color:#a6e22e>PUT</span>(<span style=color:#a6e22e>HDRP</span>(bp), <span style=color:#a6e22e>PACK</span>(size, <span style=color:#ae81ff>0</span>));
</span></span><span style=display:flex><span>        <span style=color:#a6e22e>PUT</span>(<span style=color:#a6e22e>FTRP</span>(bp), <span style=color:#a6e22e>PACK</span>(size, <span style=color:#ae81ff>0</span>));
</span></span><span style=display:flex><span>        prev_listp <span style=color:#f92672>=</span> bp;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>else</span> <span style=color:#66d9ef>if</span> (<span style=color:#f92672>!</span>prev_alloc <span style=color:#f92672>&amp;&amp;</span> next_alloc) {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span> (<span style=color:#a6e22e>PREV_BLKP</span>(bp) <span style=color:#f92672>==</span> prev_listp)
</span></span><span style=display:flex><span>            prev_listp <span style=color:#f92672>=</span> bp;
</span></span><span style=display:flex><span>        size <span style=color:#f92672>+=</span> <span style=color:#a6e22e>GET_SIZE</span>(<span style=color:#a6e22e>HDRP</span>(<span style=color:#a6e22e>PREV_BLKP</span>(bp)));
</span></span><span style=display:flex><span>        <span style=color:#a6e22e>PUT</span>(<span style=color:#a6e22e>FTRP</span>(bp), <span style=color:#a6e22e>PACK</span>(size, <span style=color:#ae81ff>0</span>));
</span></span><span style=display:flex><span>        <span style=color:#a6e22e>PUT</span>(<span style=color:#a6e22e>HDRP</span>(<span style=color:#a6e22e>PREV_BLKP</span>(bp)), <span style=color:#a6e22e>PACK</span>(size, <span style=color:#ae81ff>0</span>));
</span></span><span style=display:flex><span>        bp <span style=color:#f92672>=</span> <span style=color:#a6e22e>PREV_BLKP</span>(bp);
</span></span><span style=display:flex><span>        prev_listp <span style=color:#f92672>=</span> bp;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>else</span> {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span> (<span style=color:#a6e22e>PREV_BLKP</span>(bp) <span style=color:#f92672>==</span> prev_listp)
</span></span><span style=display:flex><span>            prev_listp <span style=color:#f92672>=</span> bp;
</span></span><span style=display:flex><span>        size <span style=color:#f92672>+=</span> <span style=color:#a6e22e>GET_SIZE</span>(<span style=color:#a6e22e>HDRP</span>(<span style=color:#a6e22e>PREV_BLKP</span>(bp))) <span style=color:#f92672>+</span>
</span></span><span style=display:flex><span>                <span style=color:#a6e22e>GET_SIZE</span>(<span style=color:#a6e22e>FTRP</span>(<span style=color:#a6e22e>NEXT_BLKP</span>(bp)));
</span></span><span style=display:flex><span>        <span style=color:#a6e22e>PUT</span>(<span style=color:#a6e22e>HDRP</span>(<span style=color:#a6e22e>PREV_BLKP</span>(bp)), <span style=color:#a6e22e>PACK</span>(size, <span style=color:#ae81ff>0</span>));
</span></span><span style=display:flex><span>        <span style=color:#a6e22e>PUT</span>(<span style=color:#a6e22e>FTRP</span>(<span style=color:#a6e22e>NEXT_BLKP</span>(bp)), <span style=color:#a6e22e>PACK</span>(size, <span style=color:#ae81ff>0</span>));
</span></span><span style=display:flex><span>        bp <span style=color:#f92672>=</span> <span style=color:#a6e22e>PREV_BLKP</span>(bp);
</span></span><span style=display:flex><span>        prev_listp <span style=color:#f92672>=</span> bp;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    <span style=color:#75715e>// prev_listp = bp;
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#66d9ef>return</span> bp;
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>/*
</span></span></span><span style=display:flex><span><span style=color:#75715e> * extend_heap - Extend the heap with a free block and return that block&#39;s payload address.
</span></span></span><span style=display:flex><span><span style=color:#75715e> */</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>static</span> <span style=color:#66d9ef>void</span> <span style=color:#f92672>*</span><span style=color:#a6e22e>extend_heap</span>(<span style=color:#66d9ef>size_t</span> words)
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>char</span> <span style=color:#f92672>*</span>bp;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>size_t</span> size;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>/* Allocate an even number of words to maintain alignment */</span>
</span></span><span style=display:flex><span>    size <span style=color:#f92672>=</span> (words <span style=color:#f92672>%</span> <span style=color:#ae81ff>2</span>) <span style=color:#f92672>?</span> (words <span style=color:#f92672>+</span> <span style=color:#ae81ff>1</span>) <span style=color:#f92672>*</span> WSIZE : words <span style=color:#f92672>*</span> WSIZE;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> ((<span style=color:#66d9ef>long</span>)(bp <span style=color:#f92672>=</span> <span style=color:#a6e22e>mem_sbrk</span>(size)) <span style=color:#f92672>==</span> <span style=color:#f92672>-</span><span style=color:#ae81ff>1</span>)
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> NULL;
</span></span><span style=display:flex><span>    
</span></span><span style=display:flex><span>    <span style=color:#75715e>/* Initialize free block header/footer and the epilogue header */</span>
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>PUT</span>(<span style=color:#a6e22e>HDRP</span>(bp), <span style=color:#a6e22e>PACK</span>(size, <span style=color:#ae81ff>0</span>));
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>PUT</span>(<span style=color:#a6e22e>FTRP</span>(bp), <span style=color:#a6e22e>PACK</span>(size, <span style=color:#ae81ff>0</span>));
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>PUT</span>(<span style=color:#a6e22e>HDRP</span>(<span style=color:#a6e22e>NEXT_BLKP</span>(bp)), <span style=color:#a6e22e>PACK</span>(<span style=color:#ae81ff>0</span>, <span style=color:#ae81ff>1</span>));
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>/* Coalesce if the previous block was free */</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> <span style=color:#a6e22e>coalesce</span>(bp);
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>/* Find freeblock that fits the request size and return it&#39;s bp */</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>static</span> <span style=color:#66d9ef>void</span> <span style=color:#f92672>*</span><span style=color:#a6e22e>find_fit</span>(<span style=color:#66d9ef>size_t</span> asize)
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>    <span style=color:#75715e>// /* Find free block that fits the requsted asize. (first fit)*/
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#75715e>// for(char* bp = heap_listp; GET_SIZE(HDRP(bp)) &gt; 0; bp = NEXT_BLKP(bp)) {
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#75715e>//     if (!GET_ALLOC(HDRP(bp)) &amp;&amp; GET_SIZE(HDRP(bp)) &gt;= asize) {
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#75715e>//         return bp;
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#75715e>//     }
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#75715e>// }
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#75715e>// return NULL;
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>/* next fit */</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>for</span> (<span style=color:#66d9ef>char</span><span style=color:#f92672>*</span> bp <span style=color:#f92672>=</span> prev_listp; <span style=color:#a6e22e>GET_SIZE</span>(<span style=color:#a6e22e>HDRP</span>(bp)) <span style=color:#f92672>&gt;</span> <span style=color:#ae81ff>0</span>; bp <span style=color:#f92672>=</span> <span style=color:#a6e22e>NEXT_BLKP</span>(bp))
</span></span><span style=display:flex><span>    {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span> (<span style=color:#f92672>!</span><span style=color:#a6e22e>GET_ALLOC</span>(<span style=color:#a6e22e>HDRP</span>(bp)) <span style=color:#f92672>&amp;&amp;</span> <span style=color:#a6e22e>GET_SIZE</span>(<span style=color:#a6e22e>HDRP</span>(bp)) <span style=color:#f92672>&gt;=</span> asize)
</span></span><span style=display:flex><span>        {
</span></span><span style=display:flex><span>            prev_listp <span style=color:#f92672>=</span> bp;
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>return</span> bp;
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>for</span> (<span style=color:#66d9ef>char</span><span style=color:#f92672>*</span> bp <span style=color:#f92672>=</span> heap_listp; bp <span style=color:#f92672>!=</span> prev_listp; bp <span style=color:#f92672>=</span> <span style=color:#a6e22e>NEXT_BLKP</span>(bp))
</span></span><span style=display:flex><span>    {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span> (<span style=color:#f92672>!</span><span style=color:#a6e22e>GET_ALLOC</span>(<span style=color:#a6e22e>HDRP</span>(bp)) <span style=color:#f92672>&amp;&amp;</span> <span style=color:#a6e22e>GET_SIZE</span>(<span style=color:#a6e22e>HDRP</span>(bp)) <span style=color:#f92672>&gt;=</span> asize)
</span></span><span style=display:flex><span>        {
</span></span><span style=display:flex><span>            prev_listp <span style=color:#f92672>=</span> bp;
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>return</span> bp;
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> NULL;
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>/* Place requested block in a free block, split if necessary */</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>static</span> <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>place</span>(<span style=color:#66d9ef>void</span> <span style=color:#f92672>*</span>bp, <span style=color:#66d9ef>size_t</span> asize)
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>size_t</span> blk_size <span style=color:#f92672>=</span> <span style=color:#a6e22e>GET_SIZE</span>(<span style=color:#a6e22e>HDRP</span>(bp));
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>size_t</span> remain_size <span style=color:#f92672>=</span> blk_size <span style=color:#f92672>-</span> asize;
</span></span><span style=display:flex><span>    
</span></span><span style=display:flex><span>    <span style=color:#75715e>/* split if we have space space */</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> ( remain_size <span style=color:#f92672>&gt;=</span> <span style=color:#ae81ff>16</span>) {
</span></span><span style=display:flex><span>        <span style=color:#75715e>/* set up malloced block */</span>
</span></span><span style=display:flex><span>        <span style=color:#a6e22e>PUT</span>(<span style=color:#a6e22e>HDRP</span>(bp), <span style=color:#a6e22e>PACK</span>(asize, <span style=color:#ae81ff>1</span>));
</span></span><span style=display:flex><span>        <span style=color:#a6e22e>PUT</span>(<span style=color:#a6e22e>FTRP</span>(bp), <span style=color:#a6e22e>PACK</span>(asize, <span style=color:#ae81ff>1</span>));
</span></span><span style=display:flex><span>        <span style=color:#75715e>/* set up spilited block */</span>
</span></span><span style=display:flex><span>        <span style=color:#a6e22e>PUT</span>(<span style=color:#a6e22e>HDRP</span>(<span style=color:#a6e22e>NEXT_BLKP</span>(bp)), <span style=color:#a6e22e>PACK</span>(remain_size, <span style=color:#ae81ff>0</span>));
</span></span><span style=display:flex><span>        <span style=color:#a6e22e>PUT</span>(<span style=color:#a6e22e>FTRP</span>(<span style=color:#a6e22e>NEXT_BLKP</span>(bp)), <span style=color:#a6e22e>PACK</span>(remain_size, <span style=color:#ae81ff>0</span>));
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>else</span> {
</span></span><span style=display:flex><span>        <span style=color:#75715e>/* set up malloced block */</span>
</span></span><span style=display:flex><span>        <span style=color:#a6e22e>PUT</span>(<span style=color:#a6e22e>HDRP</span>(bp), <span style=color:#a6e22e>PACK</span>(blk_size, <span style=color:#ae81ff>1</span>));
</span></span><span style=display:flex><span>        <span style=color:#a6e22e>PUT</span>(<span style=color:#a6e22e>FTRP</span>(bp), <span style=color:#a6e22e>PACK</span>(blk_size, <span style=color:#ae81ff>1</span>));
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    prev_listp <span style=color:#f92672>=</span> bp;
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h4 id=去掉分配块的footer的实现代码>去掉分配块的Footer的实现代码
<a class=header-anchor href=#%e5%8e%bb%e6%8e%89%e5%88%86%e9%85%8d%e5%9d%97%e7%9a%84footer%e7%9a%84%e5%ae%9e%e7%8e%b0%e4%bb%a3%e7%a0%81></a></h4><p>跑分基本上没区别&mldr;.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-fallback data-lang=fallback><span style=display:flex><span>Results for mm malloc:
</span></span><span style=display:flex><span>trace  valid  util     ops      secs  Kops
</span></span><span style=display:flex><span> 0       yes   90%    5694  0.000995  5721
</span></span><span style=display:flex><span> 1       yes   92%    5848  0.000603  9706
</span></span><span style=display:flex><span> 2       yes   94%    6648  0.001801  3692
</span></span><span style=display:flex><span> 3       yes   96%    5380  0.001816  2963
</span></span><span style=display:flex><span> 4       yes   66%   14400  0.000099146193
</span></span><span style=display:flex><span> 5       yes   89%    4800  0.003049  1574
</span></span><span style=display:flex><span> 6       yes   87%    4800  0.002710  1771
</span></span><span style=display:flex><span> 7       yes   55%   12000  0.006541  1835
</span></span><span style=display:flex><span> 8       yes   51%   24000  0.004291  5594
</span></span><span style=display:flex><span> 9       yes   26%   14401  0.031904   451
</span></span><span style=display:flex><span>10       yes   34%   14401  0.001711  8419
</span></span><span style=display:flex><span>Total          71%  112372  0.055518  2024
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>Perf index = 43 (util) + 40 (thru) = 83/100
</span></span></code></pre></div><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=display:flex><span><span style=color:#75715e>/*
</span></span></span><span style=display:flex><span><span style=color:#75715e> * mm.c - Malloc package using implicit free list. (without footer in allocated block)
</span></span></span><span style=display:flex><span><span style=color:#75715e> *        Free block&#39;s header stores its allocation status in the lowest bit)
</span></span></span><span style=display:flex><span><span style=color:#75715e> *        and its previous block&#39;s allocation status in the second lowest bit).      
</span></span></span><span style=display:flex><span><span style=color:#75715e> */</span>
</span></span><span style=display:flex><span><span style=color:#75715e>#include</span> <span style=color:#75715e>&lt;stdio.h&gt;</span><span style=color:#75715e>
</span></span></span><span style=display:flex><span><span style=color:#75715e>#include</span> <span style=color:#75715e>&lt;stdlib.h&gt;</span><span style=color:#75715e>
</span></span></span><span style=display:flex><span><span style=color:#75715e>#include</span> <span style=color:#75715e>&lt;assert.h&gt;</span><span style=color:#75715e>
</span></span></span><span style=display:flex><span><span style=color:#75715e>#include</span> <span style=color:#75715e>&lt;unistd.h&gt;</span><span style=color:#75715e>
</span></span></span><span style=display:flex><span><span style=color:#75715e>#include</span> <span style=color:#75715e>&lt;string.h&gt;</span><span style=color:#75715e>
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>
</span></span><span style=display:flex><span><span style=color:#75715e>#include</span> <span style=color:#75715e>&#34;mm.h&#34;</span><span style=color:#75715e>
</span></span></span><span style=display:flex><span><span style=color:#75715e>#include</span> <span style=color:#75715e>&#34;memlib.h&#34;</span><span style=color:#75715e>
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>
</span></span><span style=display:flex><span><span style=color:#75715e>/*********************************************************
</span></span></span><span style=display:flex><span><span style=color:#75715e> * NOTE TO STUDENTS: Before you do anything else, please
</span></span></span><span style=display:flex><span><span style=color:#75715e> * provide your team information in the following struct.
</span></span></span><span style=display:flex><span><span style=color:#75715e> ********************************************************/</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>team_t</span> team <span style=color:#f92672>=</span> {
</span></span><span style=display:flex><span>    <span style=color:#75715e>/* Team name */</span>
</span></span><span style=display:flex><span>    <span style=color:#e6db74>&#34;ateam&#34;</span>,
</span></span><span style=display:flex><span>    <span style=color:#75715e>/* First member&#39;s full name */</span>
</span></span><span style=display:flex><span>    <span style=color:#e6db74>&#34;Harry Bovik&#34;</span>,
</span></span><span style=display:flex><span>    <span style=color:#75715e>/* First member&#39;s email address */</span>
</span></span><span style=display:flex><span>    <span style=color:#e6db74>&#34;bovik@cs.cmu.edu&#34;</span>,
</span></span><span style=display:flex><span>    <span style=color:#75715e>/* Second member&#39;s full name (leave blank if none) */</span>
</span></span><span style=display:flex><span>    <span style=color:#e6db74>&#34;&#34;</span>,
</span></span><span style=display:flex><span>    <span style=color:#75715e>/* Second member&#39;s email address (leave blank if none) */</span>
</span></span><span style=display:flex><span>    <span style=color:#e6db74>&#34;&#34;</span>
</span></span><span style=display:flex><span>};
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>/* 8 bytes alignment in 32bit mode */</span>
</span></span><span style=display:flex><span><span style=color:#75715e>#define ALIGNMENT 8
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>
</span></span><span style=display:flex><span><span style=color:#75715e>/* Rounds up to the nearest multiple of ALIGNMENT */</span>
</span></span><span style=display:flex><span><span style=color:#75715e>#define ALIGN(size) (((size) + (ALIGNMENT-1)) &amp; ~0x7)
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>
</span></span><span style=display:flex><span><span style=color:#75715e>//* Basic constants and macros: */
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#75715e>#define WSIZE      4          </span><span style=color:#75715e>/* Word and header/footer size (bytes) */</span><span style=color:#75715e>
</span></span></span><span style=display:flex><span><span style=color:#75715e>#define DSIZE      8          </span><span style=color:#75715e>/* Doubleword size (bytes) */</span><span style=color:#75715e>
</span></span></span><span style=display:flex><span><span style=color:#75715e>#define CHUNKSIZE  (1&lt;&lt;12)    </span><span style=color:#75715e>/* Extend heap by this amount (bytes) */</span><span style=color:#75715e>
</span></span></span><span style=display:flex><span><span style=color:#75715e>#define MINBLOCKSIZE 8        </span><span style=color:#75715e>/* Minimum block size: WORD(HDR) + WORD(FTR) */</span><span style=color:#75715e>
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>
</span></span><span style=display:flex><span><span style=color:#75715e>/* Max value of 2 values */</span>
</span></span><span style=display:flex><span><span style=color:#75715e>#define MAX(x, y) ((x) &gt; (y) ? (x) : (y))
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>
</span></span><span style=display:flex><span><span style=color:#75715e>/* Pack a size and allocated bit into a word */</span>
</span></span><span style=display:flex><span><span style=color:#75715e>#define PACK(size, alloc)  ((size) | (alloc)) </span><span style=color:#75715e>/* `alloc` could be 0, 1, 2 or 3 */</span><span style=color:#75715e>
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>
</span></span><span style=display:flex><span><span style=color:#75715e>/* Read and write a word at address p. */</span>
</span></span><span style=display:flex><span><span style=color:#75715e>#define GET(p)       (*(unsigned int *)(p))
</span></span></span><span style=display:flex><span><span style=color:#75715e>#define PUT(p, val)  (*(unsigned int *)(p) = (val))
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>
</span></span><span style=display:flex><span><span style=color:#75715e>/* Read the size and allocated fields from address p */</span>
</span></span><span style=display:flex><span><span style=color:#75715e>#define GET_SIZE(p)   (GET(p) &amp; ~0x7) </span><span style=color:#75715e>/* Take attention!!! size = header + payload + footer */</span><span style=color:#75715e>
</span></span></span><span style=display:flex><span><span style=color:#75715e>#define GET_ALLOC(p)  (GET(p) &amp; 0x1)
</span></span></span><span style=display:flex><span><span style=color:#75715e>#define GET_PREV_ALLOC(p)  (GET(p) &amp; 0x2)
</span></span></span><span style=display:flex><span><span style=color:#75715e>#define GET_PREALLOC(p) (GET(p) &amp; 0x2)
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>
</span></span><span style=display:flex><span><span style=color:#75715e>/* Set and clear prev_alloc status at adress p*/</span>
</span></span><span style=display:flex><span><span style=color:#75715e>#define SET_PREV_ALLOC(p) (PUT(p, GET(p) | 0x2))
</span></span></span><span style=display:flex><span><span style=color:#75715e>#define CLR_PREV_ALLOC(p) (PUT(p, GET(p) &amp; ~0x2))
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>
</span></span><span style=display:flex><span><span style=color:#75715e>/* Given block ptr bp, compute address of its header and footer */</span>
</span></span><span style=display:flex><span><span style=color:#75715e>#define HDRP(bp)  ((char *)(bp) - WSIZE)
</span></span></span><span style=display:flex><span><span style=color:#75715e>#define FTRP(bp)  ((char *)(bp) + GET_SIZE(HDRP(bp)) - DSIZE)
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>
</span></span><span style=display:flex><span><span style=color:#75715e>/* Given block ptr bp, compute address of next and previous blocks */</span>
</span></span><span style=display:flex><span><span style=color:#75715e>#define NEXT_BLKP(bp)  ((char *)(bp) + GET_SIZE(HDRP(bp)))
</span></span></span><span style=display:flex><span><span style=color:#75715e>#define PREV_BLKP(bp)  ((char *)(bp) - GET_SIZE((char *)(bp) - DSIZE))
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>
</span></span><span style=display:flex><span><span style=color:#75715e>/* Global declarations */</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>static</span> <span style=color:#66d9ef>char</span> <span style=color:#f92672>*</span>heap_listp, <span style=color:#f92672>*</span>prev_listp;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>/* Function prototypes for internal helper routines */</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>static</span> <span style=color:#66d9ef>void</span> <span style=color:#f92672>*</span><span style=color:#a6e22e>coalesce</span>(<span style=color:#66d9ef>void</span> <span style=color:#f92672>*</span>bp);
</span></span><span style=display:flex><span><span style=color:#66d9ef>static</span> <span style=color:#66d9ef>void</span> <span style=color:#f92672>*</span><span style=color:#a6e22e>extend_heap</span>(<span style=color:#66d9ef>size_t</span> words);
</span></span><span style=display:flex><span><span style=color:#66d9ef>static</span> <span style=color:#66d9ef>void</span> <span style=color:#f92672>*</span><span style=color:#a6e22e>find_fit</span>(<span style=color:#66d9ef>size_t</span> asize);
</span></span><span style=display:flex><span><span style=color:#66d9ef>static</span> <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>place</span>(<span style=color:#66d9ef>void</span> <span style=color:#f92672>*</span>bp, <span style=color:#66d9ef>size_t</span> asize);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>/* 
</span></span></span><span style=display:flex><span><span style=color:#75715e> * mm_init - initialize the malloc package.
</span></span></span><span style=display:flex><span><span style=color:#75715e> */</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>int</span> <span style=color:#a6e22e>mm_init</span>(<span style=color:#66d9ef>void</span>)
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>    <span style=color:#75715e>/* Create the initial empty heap */</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> ((heap_listp <span style=color:#f92672>=</span> <span style=color:#a6e22e>mem_sbrk</span>(<span style=color:#ae81ff>4</span><span style=color:#f92672>*</span>WSIZE)) <span style=color:#f92672>==</span> (<span style=color:#66d9ef>void</span> <span style=color:#f92672>*</span>) <span style=color:#f92672>-</span><span style=color:#ae81ff>1</span>)
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> <span style=color:#f92672>-</span><span style=color:#ae81ff>1</span>;
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>PUT</span>(heap_listp, <span style=color:#ae81ff>0</span>);                             <span style=color:#75715e>/* alignment padding */</span>
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>PUT</span>(heap_listp <span style=color:#f92672>+</span> (<span style=color:#ae81ff>1</span><span style=color:#f92672>*</span>WSIZE), <span style=color:#a6e22e>PACK</span>(DSIZE, <span style=color:#ae81ff>3</span>));    <span style=color:#75715e>/* Prologue header */</span>
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>PUT</span>(heap_listp <span style=color:#f92672>+</span> (<span style=color:#ae81ff>2</span><span style=color:#f92672>*</span>WSIZE), <span style=color:#a6e22e>PACK</span>(DSIZE, <span style=color:#ae81ff>3</span>));    <span style=color:#75715e>/* Prologue footer */</span>
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>PUT</span>(heap_listp <span style=color:#f92672>+</span> (<span style=color:#ae81ff>3</span><span style=color:#f92672>*</span>WSIZE), <span style=color:#a6e22e>PACK</span>(<span style=color:#ae81ff>0</span>, <span style=color:#ae81ff>3</span>));    <span style=color:#75715e>/* Epilogue header */</span>
</span></span><span style=display:flex><span>    heap_listp <span style=color:#f92672>+=</span> (<span style=color:#ae81ff>2</span><span style=color:#f92672>*</span>WSIZE);    <span style=color:#75715e>/* make heap_listp points to epilogue header */</span>
</span></span><span style=display:flex><span>    prev_listp <span style=color:#f92672>=</span> heap_listp;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>/* Extend the empty heap with a free block of CHUNKSIZE bytes */</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> (<span style=color:#a6e22e>extend_heap</span>(CHUNKSIZE<span style=color:#f92672>/</span>WSIZE) <span style=color:#f92672>==</span> NULL)
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> <span style=color:#f92672>-</span><span style=color:#ae81ff>1</span>;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> <span style=color:#ae81ff>0</span>;
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>/* 
</span></span></span><span style=display:flex><span><span style=color:#75715e> * mm_malloc - Allocate a block by incrementing the brk pointer.
</span></span></span><span style=display:flex><span><span style=color:#75715e> *             Always allocate a block whose size is a multiple of the alignment.
</span></span></span><span style=display:flex><span><span style=color:#75715e> */</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>void</span> <span style=color:#f92672>*</span><span style=color:#a6e22e>mm_malloc</span>(<span style=color:#66d9ef>size_t</span> size)
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>size_t</span> asize; <span style=color:#75715e>/* Adjusted block size */</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>size_t</span> extendsize; <span style=color:#75715e>/* Amount to extend heap if not fit */</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>char</span> <span style=color:#f92672>*</span>bp;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>/* Ignore spurious requests */</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> (size <span style=color:#f92672>==</span> <span style=color:#ae81ff>0</span>) {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> NULL;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>/* Adjust block size to include overhead and alignment reqs */</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> (size <span style=color:#f92672>&lt;</span> WSIZE)
</span></span><span style=display:flex><span>        asize <span style=color:#f92672>=</span> MINBLOCKSIZE;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>else</span>
</span></span><span style=display:flex><span>        asize <span style=color:#f92672>=</span> <span style=color:#a6e22e>ALIGN</span>(size <span style=color:#f92672>+</span> <span style=color:#ae81ff>4</span>);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>/* Search the free list for a fit */</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> ((bp <span style=color:#f92672>=</span> <span style=color:#a6e22e>find_fit</span>(asize)) <span style=color:#f92672>!=</span> NULL) {
</span></span><span style=display:flex><span>        <span style=color:#a6e22e>place</span>(bp, asize);
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> bp;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>/* No fit. Get more memory and place the block */</span>
</span></span><span style=display:flex><span>    extendsize <span style=color:#f92672>=</span> <span style=color:#a6e22e>MAX</span>(asize, CHUNKSIZE);
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> ((bp <span style=color:#f92672>=</span> <span style=color:#a6e22e>extend_heap</span>(extendsize <span style=color:#f92672>/</span> WSIZE)) <span style=color:#f92672>==</span> NULL)
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> NULL;
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>place</span>(bp, asize);
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> bp;
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>/*
</span></span></span><span style=display:flex><span><span style=color:#75715e> * mm_free - Freeing a block and coalesce if necessary.
</span></span></span><span style=display:flex><span><span style=color:#75715e> */</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>void</span> <span style=color:#a6e22e>mm_free</span>(<span style=color:#66d9ef>void</span> <span style=color:#f92672>*</span>bp)
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>size_t</span> size <span style=color:#f92672>=</span> <span style=color:#a6e22e>GET_SIZE</span>(<span style=color:#a6e22e>HDRP</span>(bp));
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>PUT</span>(<span style=color:#a6e22e>HDRP</span>(bp), <span style=color:#a6e22e>PACK</span>(size, <span style=color:#a6e22e>GET_PREV_ALLOC</span>(<span style=color:#a6e22e>HDRP</span>(bp))));
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>PUT</span>(<span style=color:#a6e22e>FTRP</span>(bp), <span style=color:#a6e22e>PACK</span>(size, <span style=color:#a6e22e>GET_PREV_ALLOC</span>(<span style=color:#a6e22e>HDRP</span>(bp))));
</span></span><span style=display:flex><span>    
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>coalesce</span>(bp);
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>/*
</span></span></span><span style=display:flex><span><span style=color:#75715e> * mm_realloc - Implemented simply in terms of mm_malloc and mm_free
</span></span></span><span style=display:flex><span><span style=color:#75715e> */</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>void</span> <span style=color:#f92672>*</span><span style=color:#a6e22e>mm_realloc</span>(<span style=color:#66d9ef>void</span> <span style=color:#f92672>*</span>ptr, <span style=color:#66d9ef>size_t</span> size)
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> (ptr <span style=color:#f92672>==</span> NULL)
</span></span><span style=display:flex><span>       <span style=color:#66d9ef>return</span> <span style=color:#a6e22e>mm_malloc</span>(size);
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> (size <span style=color:#f92672>==</span> <span style=color:#ae81ff>0</span>) 
</span></span><span style=display:flex><span>       <span style=color:#a6e22e>mm_free</span>(ptr);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>void</span> <span style=color:#f92672>*</span>oldptr <span style=color:#f92672>=</span> ptr;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>void</span> <span style=color:#f92672>*</span>newptr;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>size_t</span> copySize;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    newptr <span style=color:#f92672>=</span> <span style=color:#a6e22e>mm_malloc</span>(size);
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> (newptr <span style=color:#f92672>==</span> NULL)
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> NULL;
</span></span><span style=display:flex><span>    size <span style=color:#f92672>=</span> <span style=color:#a6e22e>GET_SIZE</span>(<span style=color:#a6e22e>HDRP</span>(oldptr));
</span></span><span style=display:flex><span>    copySize <span style=color:#f92672>=</span> <span style=color:#a6e22e>GET_SIZE</span>(<span style=color:#a6e22e>HDRP</span>(newptr));
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> (size <span style=color:#f92672>&lt;</span> copySize)
</span></span><span style=display:flex><span>        copySize <span style=color:#f92672>=</span> size;
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>memcpy</span>(newptr, oldptr, copySize<span style=color:#f92672>-</span>WSIZE);
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>mm_free</span>(oldptr);
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> newptr;
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>/*
</span></span></span><span style=display:flex><span><span style=color:#75715e> * coalesce - Merge freed block.
</span></span></span><span style=display:flex><span><span style=color:#75715e> */</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>static</span> <span style=color:#66d9ef>void</span><span style=color:#f92672>*</span> <span style=color:#a6e22e>coalesce</span>(<span style=color:#66d9ef>void</span><span style=color:#f92672>*</span> bp)
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>void</span><span style=color:#f92672>*</span> prev_bp <span style=color:#f92672>=</span> <span style=color:#a6e22e>PREV_BLKP</span>(bp);
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>void</span><span style=color:#f92672>*</span> next_bp <span style=color:#f92672>=</span> <span style=color:#a6e22e>NEXT_BLKP</span>(bp);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>size_t</span> prev_alloc <span style=color:#f92672>=</span> <span style=color:#a6e22e>GET_PREV_ALLOC</span>(<span style=color:#a6e22e>HDRP</span>(bp)); <span style=color:#75715e>/* Now prev allocation status is in our current header */</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>size_t</span> next_alloc <span style=color:#f92672>=</span> <span style=color:#a6e22e>GET_ALLOC</span>(<span style=color:#a6e22e>HDRP</span>(<span style=color:#a6e22e>NEXT_BLKP</span>(bp)));
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>size_t</span> size <span style=color:#f92672>=</span> <span style=color:#a6e22e>GET_SIZE</span>(<span style=color:#a6e22e>HDRP</span>(bp));
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> (prev_alloc <span style=color:#f92672>&amp;&amp;</span> next_alloc) {
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>else</span> <span style=color:#66d9ef>if</span> (prev_alloc <span style=color:#f92672>&amp;&amp;</span> <span style=color:#f92672>!</span>next_alloc) {
</span></span><span style=display:flex><span>        size <span style=color:#f92672>+=</span> <span style=color:#a6e22e>GET_SIZE</span>(<span style=color:#a6e22e>HDRP</span>(next_bp));
</span></span><span style=display:flex><span>        <span style=color:#a6e22e>PUT</span>(<span style=color:#a6e22e>FTRP</span>(next_bp), <span style=color:#a6e22e>PACK</span>(size, <span style=color:#ae81ff>2</span>));
</span></span><span style=display:flex><span>        <span style=color:#a6e22e>PUT</span>(<span style=color:#a6e22e>HDRP</span>(bp), <span style=color:#a6e22e>PACK</span>(size, <span style=color:#ae81ff>2</span>));
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>else</span> <span style=color:#66d9ef>if</span> (<span style=color:#f92672>!</span>prev_alloc <span style=color:#f92672>&amp;&amp;</span> next_alloc) {
</span></span><span style=display:flex><span>        size <span style=color:#f92672>+=</span> <span style=color:#a6e22e>GET_SIZE</span>(<span style=color:#a6e22e>HDRP</span>(prev_bp));
</span></span><span style=display:flex><span>        <span style=color:#a6e22e>PUT</span>(<span style=color:#a6e22e>FTRP</span>(bp), <span style=color:#a6e22e>PACK</span>(size, <span style=color:#ae81ff>2</span>));
</span></span><span style=display:flex><span>        <span style=color:#a6e22e>PUT</span>(<span style=color:#a6e22e>HDRP</span>(prev_bp), <span style=color:#a6e22e>PACK</span>(size, <span style=color:#ae81ff>2</span>)); <span style=color:#75715e>/* prev is free, PREV_BLKP(prev) must be allocated */</span>
</span></span><span style=display:flex><span>        bp <span style=color:#f92672>=</span> prev_bp;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>else</span> {
</span></span><span style=display:flex><span>        size <span style=color:#f92672>+=</span> <span style=color:#a6e22e>GET_SIZE</span>(<span style=color:#a6e22e>HDRP</span>(prev_bp)) <span style=color:#f92672>+</span>
</span></span><span style=display:flex><span>                <span style=color:#a6e22e>GET_SIZE</span>(<span style=color:#a6e22e>FTRP</span>(next_bp));
</span></span><span style=display:flex><span>        <span style=color:#a6e22e>PUT</span>(<span style=color:#a6e22e>FTRP</span>(next_bp), <span style=color:#a6e22e>PACK</span>(size, <span style=color:#ae81ff>2</span>));
</span></span><span style=display:flex><span>        <span style=color:#a6e22e>PUT</span>(<span style=color:#a6e22e>HDRP</span>(prev_bp), <span style=color:#a6e22e>PACK</span>(size, <span style=color:#ae81ff>2</span>));
</span></span><span style=display:flex><span>        bp <span style=color:#f92672>=</span> prev_bp;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>CLR_PREV_ALLOC</span>(<span style=color:#a6e22e>HDRP</span>(<span style=color:#a6e22e>NEXT_BLKP</span>(bp)));
</span></span><span style=display:flex><span>    prev_listp <span style=color:#f92672>=</span> bp;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> bp;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>/*
</span></span></span><span style=display:flex><span><span style=color:#75715e> * extend_heap - Extend the heap with a free block and return that block&#39;s payload address.
</span></span></span><span style=display:flex><span><span style=color:#75715e> */</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>static</span> <span style=color:#66d9ef>void</span> <span style=color:#f92672>*</span><span style=color:#a6e22e>extend_heap</span>(<span style=color:#66d9ef>size_t</span> words)
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>char</span> <span style=color:#f92672>*</span>bp;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>size_t</span> size;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>/* Allocate an even number of words to maintain alignment */</span>
</span></span><span style=display:flex><span>    size <span style=color:#f92672>=</span> (words <span style=color:#f92672>%</span> <span style=color:#ae81ff>2</span>) <span style=color:#f92672>?</span> (words <span style=color:#f92672>+</span> <span style=color:#ae81ff>1</span>) <span style=color:#f92672>*</span> WSIZE : words <span style=color:#f92672>*</span> WSIZE;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> ((<span style=color:#66d9ef>long</span>)(bp <span style=color:#f92672>=</span> <span style=color:#a6e22e>mem_sbrk</span>(size)) <span style=color:#f92672>==</span> <span style=color:#f92672>-</span><span style=color:#ae81ff>1</span>)
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> NULL;
</span></span><span style=display:flex><span>    
</span></span><span style=display:flex><span>    <span style=color:#75715e>/* Initialize free block header/footer and the epilogue header */</span>
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>PUT</span>(<span style=color:#a6e22e>HDRP</span>(bp), <span style=color:#a6e22e>PACK</span>(size, <span style=color:#a6e22e>GET_PREV_ALLOC</span>(<span style=color:#a6e22e>HDRP</span>(bp))));
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>PUT</span>(<span style=color:#a6e22e>FTRP</span>(bp), <span style=color:#a6e22e>PACK</span>(size, <span style=color:#a6e22e>GET_PREV_ALLOC</span>(<span style=color:#a6e22e>HDRP</span>(bp))));
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>PUT</span>(<span style=color:#a6e22e>HDRP</span>(<span style=color:#a6e22e>NEXT_BLKP</span>(bp)), <span style=color:#a6e22e>PACK</span>(<span style=color:#ae81ff>0</span>, <span style=color:#ae81ff>1</span>));
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>/* Coalesce if the previous block was free */</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> <span style=color:#a6e22e>coalesce</span>(bp);
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>/* Find freeblock that fits the request size and return it&#39;s bp */</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>static</span> <span style=color:#66d9ef>void</span> <span style=color:#f92672>*</span><span style=color:#a6e22e>find_fit</span>(<span style=color:#66d9ef>size_t</span> asize)
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>for</span> (<span style=color:#66d9ef>char</span><span style=color:#f92672>*</span> bp <span style=color:#f92672>=</span> prev_listp; <span style=color:#a6e22e>GET_SIZE</span>(<span style=color:#a6e22e>HDRP</span>(bp)) <span style=color:#f92672>&gt;</span> <span style=color:#ae81ff>0</span>; bp <span style=color:#f92672>=</span> <span style=color:#a6e22e>NEXT_BLKP</span>(bp))
</span></span><span style=display:flex><span>    {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span> (<span style=color:#f92672>!</span><span style=color:#a6e22e>GET_ALLOC</span>(<span style=color:#a6e22e>HDRP</span>(bp)) <span style=color:#f92672>&amp;&amp;</span> <span style=color:#a6e22e>GET_SIZE</span>(<span style=color:#a6e22e>HDRP</span>(bp)) <span style=color:#f92672>&gt;=</span> asize)
</span></span><span style=display:flex><span>        {
</span></span><span style=display:flex><span>            prev_listp <span style=color:#f92672>=</span> bp;
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>return</span> bp;
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>for</span> (<span style=color:#66d9ef>char</span><span style=color:#f92672>*</span> bp <span style=color:#f92672>=</span> heap_listp; bp <span style=color:#f92672>!=</span> prev_listp; bp <span style=color:#f92672>=</span> <span style=color:#a6e22e>NEXT_BLKP</span>(bp))
</span></span><span style=display:flex><span>    {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span> (<span style=color:#f92672>!</span><span style=color:#a6e22e>GET_ALLOC</span>(<span style=color:#a6e22e>HDRP</span>(bp)) <span style=color:#f92672>&amp;&amp;</span> <span style=color:#a6e22e>GET_SIZE</span>(<span style=color:#a6e22e>HDRP</span>(bp)) <span style=color:#f92672>&gt;=</span> asize)
</span></span><span style=display:flex><span>        {
</span></span><span style=display:flex><span>            prev_listp <span style=color:#f92672>=</span> bp;
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>return</span> bp;
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> NULL;
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>/* Place requested block in a free block, split if necessary */</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>static</span> <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>place</span>(<span style=color:#66d9ef>void</span> <span style=color:#f92672>*</span>bp, <span style=color:#66d9ef>size_t</span> asize)
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>size_t</span> blk_size <span style=color:#f92672>=</span> <span style=color:#a6e22e>GET_SIZE</span>(<span style=color:#a6e22e>HDRP</span>(bp));
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>size_t</span> remain_size <span style=color:#f92672>=</span> blk_size <span style=color:#f92672>-</span> asize;
</span></span><span style=display:flex><span>    
</span></span><span style=display:flex><span>    <span style=color:#75715e>/* split if we have space space */</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> ( remain_size <span style=color:#f92672>&gt;=</span> MINBLOCKSIZE) {
</span></span><span style=display:flex><span>        <span style=color:#75715e>/* |4 Byte HDR| Payload | 4 Bytes FTR| */</span>
</span></span><span style=display:flex><span>        <span style=color:#75715e>/* set up malloced block */</span>
</span></span><span style=display:flex><span>        <span style=color:#a6e22e>PUT</span>(<span style=color:#a6e22e>HDRP</span>(bp), <span style=color:#a6e22e>PACK</span>(asize, <span style=color:#ae81ff>3</span>));
</span></span><span style=display:flex><span>        <span style=color:#75715e>/* set up spilited block */</span>
</span></span><span style=display:flex><span>        <span style=color:#a6e22e>PUT</span>(<span style=color:#a6e22e>HDRP</span>(<span style=color:#a6e22e>NEXT_BLKP</span>(bp)), <span style=color:#a6e22e>PACK</span>(remain_size, <span style=color:#ae81ff>2</span>));
</span></span><span style=display:flex><span>        <span style=color:#a6e22e>PUT</span>(<span style=color:#a6e22e>FTRP</span>(<span style=color:#a6e22e>NEXT_BLKP</span>(bp)), <span style=color:#a6e22e>PACK</span>(remain_size, <span style=color:#ae81ff>2</span>));
</span></span><span style=display:flex><span>        <span style=color:#75715e>/* Clear alloc status of next */</span>
</span></span><span style=display:flex><span>        <span style=color:#a6e22e>CLR_PREV_ALLOC</span>(<span style=color:#a6e22e>HDRP</span>(<span style=color:#a6e22e>NEXT_BLKP</span>(<span style=color:#a6e22e>NEXT_BLKP</span>(bp))));
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>else</span> {
</span></span><span style=display:flex><span>        <span style=color:#75715e>/* set up malloced block */</span>
</span></span><span style=display:flex><span>        <span style=color:#a6e22e>PUT</span>(<span style=color:#a6e22e>HDRP</span>(bp), <span style=color:#a6e22e>PACK</span>(blk_size, <span style=color:#ae81ff>3</span>));
</span></span><span style=display:flex><span>        <span style=color:#75715e>/* Set alloc status of next block */</span>
</span></span><span style=display:flex><span>        <span style=color:#a6e22e>SET_PREV_ALLOC</span>(<span style=color:#a6e22e>HDRP</span>(<span style=color:#a6e22e>NEXT_BLKP</span>(bp)));
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    prev_listp <span style=color:#f92672>=</span> bp;
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h3 id=实现二explicit-free-list显示空闲链表>实现二：Explicit Free List（显示空闲链表）
<a class=header-anchor href=#%e5%ae%9e%e7%8e%b0%e4%ba%8cexplicit-free-list%e6%98%be%e7%a4%ba%e7%a9%ba%e9%97%b2%e9%93%be%e8%a1%a8></a></h3><h4 id=如何保存内存块的信息-1>如何保存内存块的信息？
<a class=header-anchor href=#%e5%a6%82%e4%bd%95%e4%bf%9d%e5%ad%98%e5%86%85%e5%ad%98%e5%9d%97%e7%9a%84%e4%bf%a1%e6%81%af-1></a></h4><p>上面的实现有一个问题：每次在寻找未分配的块时需要同时遍历已分配的块和未分配的块，遍历已分配的块的操作显然是多余的。</p><p>一种更好的方法是将空闲块组织为某种形式的显示数据结构（双向链表），可以巧妙利用空闲块的 payload 部分来保存这个数据结构的指针（前驱 pred 和后继 succ）。如下图所示</p><p><img src=/imgs/img-lazy-loading.gif data-src=image-20221006172812256.png alt=image-20221006172812256></p><h4 id=堆块的放置合并分割>堆块的放置、合并、分割
<a class=header-anchor href=#%e5%a0%86%e5%9d%97%e7%9a%84%e6%94%be%e7%bd%ae%e5%90%88%e5%b9%b6%e5%88%86%e5%89%b2></a></h4><p>使用显式空闲链表，使首次适配（first fit）的分配时间从块总数的线性时间减少到了空闲块数量的线性时间。不过，释放一个块的时间可以是线性的，也可能是个常数，这取决于我们所选择的空闲链表中块的排序策略。</p><p>一种方法是用后进先出（LIFO）的顺序维护链表，将新释放的块放到链表的开头，使用LIFO和First Fit的放置策略释放堆块可以在常数时间内完成。如果使用了边界标记则合并堆块（基于堆地址的线性合并）也可以在常数时间内完成。</p><p>另一种方法是按地址顺序维护链表，后继的地址大于前驱块的地址，这种情况下，释放一个块需要线性时间来搜索链表确定前驱。但是，按照地址排序的首次适配比 LIFO 排序的首次适配有更高的内存利用率，接近最佳适配的利用率。</p><p>显式链表的缺点是空闲块必须足够大，以包含所有需要的指针，以及头部和可能的脚部。这就导致了更大的最小块大小，也潜在地提高了内部碎片的程度。</p><h4 id=分配器设计-1>分配器设计
<a class=header-anchor href=#%e5%88%86%e9%85%8d%e5%99%a8%e8%ae%be%e8%ae%a1-1></a></h4><p>链表的形式和之前一样，唯一的区别就是空闲块的 payload 用于存放链表的指针</p><p><img src=/imgs/img-lazy-loading.gif data-src=image-20221006182237824.png alt=image-20221006182237824></p><p>双向链表的维护比较复杂，建议把每种情况都考虑清楚再开始写代码，不然就是无尽的 debug</p><h5 id=逻辑分析>逻辑分析
<a class=header-anchor href=#%e9%80%bb%e8%be%91%e5%88%86%e6%9e%90></a></h5><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-text data-lang=text><span style=display:flex><span>mm_init():
</span></span><span style=display:flex><span>HEAP: Padding|Prologue|Prologue|Epilogue, Free list = NULL
</span></span><span style=display:flex><span>--&gt;extend_head(4096):
</span></span><span style=display:flex><span>        Padding|Prologue|Prologue|HDR|Payload|FTR|Epilogue, Free list: NULL
</span></span><span style=display:flex><span>        --&gt;coalesce(bp): No merge
</span></span><span style=display:flex><span>           --&gt;insert(bp)
</span></span><span style=display:flex><span>HEAP: Padding|Prologue|Prologue|HDR|Payload|FTR|Epilogue, Free list: Payload
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>malloc(size):
</span></span><span style=display:flex><span>Padding|Prologue|Prologue|(HDR|Payload|FTR)n|Epilogue, Free list: Payload
</span></span><span style=display:flex><span>    /* Case 1 */
</span></span><span style=display:flex><span>    --&gt;find_fit(size): Found Fit. Return bp of Payload
</span></span><span style=display:flex><span>    --&gt;place(bp): Split
</span></span><span style=display:flex><span>        --&gt;remove(bp): Free list: NULL
</span></span><span style=display:flex><span>        --&gt;coalesce(NEXT_BLKP(bp)): No merge. Prev/Next block must be allocated since current is Free.
</span></span><span style=display:flex><span>           --&gt;insert(NEXT_BLKP(bp))
</span></span><span style=display:flex><span>              Free list: NEXT_BLKP(bp)
</span></span><span style=display:flex><span>    --&gt;place(bp): No Split:
</span></span><span style=display:flex><span>        --&gt;remove(bp):
</span></span><span style=display:flex><span>           Free list: NULL
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    /* Case 2 */
</span></span><span style=display:flex><span>    --&gt;find_fit(size): No Fit. Return NULL;
</span></span><span style=display:flex><span>    --&gt;extend_heap(MAX(size, chunksize)
</span></span><span style=display:flex><span>        --&gt;coalesce(new_bp)
</span></span><span style=display:flex><span>            /* Case 1: No merge */
</span></span><span style=display:flex><span>            --&gt;insert(new_bp)
</span></span><span style=display:flex><span>            /* Case 2: Merg prev. Return PREV_BLKP(new_bp) */
</span></span><span style=display:flex><span>    bp = return value of extend_heap(): new_bp or PREV_BLKP(new_bp)
</span></span><span style=display:flex><span>    --&gt;place(bp): Split
</span></span><span style=display:flex><span>        --&gt;remove(bp);
</span></span><span style=display:flex><span>        --&gt;coalesce(NEXT_BLKP(bp)): No Merge. We&#39;ve just extended heap, NEXT_BLKP(bp) is LAST BLOCK
</span></span><span style=display:flex><span>           --&gt;insert(NEXT_BLKP(bp))
</span></span><span style=display:flex><span>    --&gt;place(bp): No Split:
</span></span><span style=display:flex><span>        --&gt;remove(bp): Okay, bp newly added to free list or already in it.
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>free(bp):
</span></span><span style=display:flex><span>    --&gt;coalesce(bp):
</span></span><span style=display:flex><span>       /* Case 1. No merge. */
</span></span><span style=display:flex><span>       --&gt;insert(bp)
</span></span><span style=display:flex><span>       /* Case 2. Merg prev. */
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>       /* Case 3. Merg next. Remove next block. */
</span></span><span style=display:flex><span>        --&gt;remove(next_bp)
</span></span><span style=display:flex><span>        --&gt;insert(bp)
</span></span><span style=display:flex><span>       /* Case 4. Merg prev and next. Remove next block. */
</span></span><span style=display:flex><span>        --&gt;remove(next_bp)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>realloc(bp):
</span></span><span style=display:flex><span>it&#39;s just malloc, memcpy and free.
</span></span></code></pre></div><h4 id=实现代码-1>实现代码
<a class=header-anchor href=#%e5%ae%9e%e7%8e%b0%e4%bb%a3%e7%a0%81-1></a></h4><p>使用LIFO顺序维护链表，First Fit和边界标记的显式空闲链表分配器实现如下，貌似性能并不如Implicit Free List，猜测是插入方式的原因</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-fallback data-lang=fallback><span style=display:flex><span>Results for mm malloc:
</span></span><span style=display:flex><span>trace  valid  util     ops      secs  Kops
</span></span><span style=display:flex><span> 0       yes   88%    5694  0.000233 24490
</span></span><span style=display:flex><span> 1       yes   93%    5848  0.000192 30538
</span></span><span style=display:flex><span> 2       yes   95%    6648  0.000325 20487
</span></span><span style=display:flex><span> 3       yes   97%    5380  0.000267 20112
</span></span><span style=display:flex><span> 4       yes   66%   14400  0.000307 46936
</span></span><span style=display:flex><span> 5       yes   89%    4800  0.000503  9541
</span></span><span style=display:flex><span> 6       yes   88%    4800  0.000483  9940
</span></span><span style=display:flex><span> 7       yes   55%   12000  0.001122 10698
</span></span><span style=display:flex><span> 8       yes   51%   24000  0.001411 17004
</span></span><span style=display:flex><span> 9       yes   27%   14401  0.032037   450
</span></span><span style=display:flex><span>10       yes   30%   14401  0.002032  7087
</span></span><span style=display:flex><span>Total          71%  112372  0.038911  2888
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>Perf index = 42 (util) + 40 (thru) = 82/100
</span></span></code></pre></div><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=display:flex><span><span style=color:#75715e>/*
</span></span></span><span style=display:flex><span><span style=color:#75715e> * mm.c - Malloc package using explicit free list.
</span></span></span><span style=display:flex><span><span style=color:#75715e> *        Newly freed block will be inserted to the head of free list.
</span></span></span><span style=display:flex><span><span style=color:#75715e> */</span>
</span></span><span style=display:flex><span><span style=color:#75715e>#include</span> <span style=color:#75715e>&lt;stddef.h&gt;</span><span style=color:#75715e>
</span></span></span><span style=display:flex><span><span style=color:#75715e>#include</span> <span style=color:#75715e>&lt;stdio.h&gt;</span><span style=color:#75715e>
</span></span></span><span style=display:flex><span><span style=color:#75715e>#include</span> <span style=color:#75715e>&lt;stdlib.h&gt;</span><span style=color:#75715e>
</span></span></span><span style=display:flex><span><span style=color:#75715e>#include</span> <span style=color:#75715e>&lt;assert.h&gt;</span><span style=color:#75715e>
</span></span></span><span style=display:flex><span><span style=color:#75715e>#include</span> <span style=color:#75715e>&lt;unistd.h&gt;</span><span style=color:#75715e>
</span></span></span><span style=display:flex><span><span style=color:#75715e>#include</span> <span style=color:#75715e>&lt;string.h&gt;</span><span style=color:#75715e>
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>
</span></span><span style=display:flex><span><span style=color:#75715e>#include</span> <span style=color:#75715e>&#34;mm.h&#34;</span><span style=color:#75715e>
</span></span></span><span style=display:flex><span><span style=color:#75715e>#include</span> <span style=color:#75715e>&#34;memlib.h&#34;</span><span style=color:#75715e>
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>
</span></span><span style=display:flex><span><span style=color:#75715e>/*********************************************************
</span></span></span><span style=display:flex><span><span style=color:#75715e> * NOTE TO STUDENTS: Before you do anything else, please
</span></span></span><span style=display:flex><span><span style=color:#75715e> * provide your team information in the following struct.
</span></span></span><span style=display:flex><span><span style=color:#75715e> ********************************************************/</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>team_t</span> team <span style=color:#f92672>=</span> {
</span></span><span style=display:flex><span>    <span style=color:#75715e>/* Team name */</span>
</span></span><span style=display:flex><span>    <span style=color:#e6db74>&#34;ateam&#34;</span>,
</span></span><span style=display:flex><span>    <span style=color:#75715e>/* First member&#39;s full name */</span>
</span></span><span style=display:flex><span>    <span style=color:#e6db74>&#34;Harry Bovik&#34;</span>,
</span></span><span style=display:flex><span>    <span style=color:#75715e>/* First member&#39;s email address */</span>
</span></span><span style=display:flex><span>    <span style=color:#e6db74>&#34;bovik@cs.cmu.edu&#34;</span>,
</span></span><span style=display:flex><span>    <span style=color:#75715e>/* Second member&#39;s full name (leave blank if none) */</span>
</span></span><span style=display:flex><span>    <span style=color:#e6db74>&#34;&#34;</span>,
</span></span><span style=display:flex><span>    <span style=color:#75715e>/* Second member&#39;s email address (leave blank if none) */</span>
</span></span><span style=display:flex><span>    <span style=color:#e6db74>&#34;&#34;</span>
</span></span><span style=display:flex><span>};
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>// #define DEBUG
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#75715e>#ifdef DEBUG
</span></span></span><span style=display:flex><span><span style=color:#75715e># define DBG_PRINTF(...) printf(__VA_ARGS__)
</span></span></span><span style=display:flex><span><span style=color:#75715e># define CHECKHEAP(verbose) mm_checkheap(verbose)
</span></span></span><span style=display:flex><span><span style=color:#75715e>#else
</span></span></span><span style=display:flex><span><span style=color:#75715e># define DBG_PRINTF(...)
</span></span></span><span style=display:flex><span><span style=color:#75715e># define CHECKHEAP(verbose)
</span></span></span><span style=display:flex><span><span style=color:#75715e>#endif
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>/* 8 bytes alignment in 32bit mode */</span>
</span></span><span style=display:flex><span><span style=color:#75715e>#define ALIGNMENT 8
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>
</span></span><span style=display:flex><span><span style=color:#75715e>/* Rounds up to the nearest multiple of ALIGNMENT */</span>
</span></span><span style=display:flex><span><span style=color:#75715e>#define ALIGN(size) (((size) + (ALIGNMENT-1)) &amp; ~0x7)
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>
</span></span><span style=display:flex><span><span style=color:#75715e>//* Basic constants and macros: */
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#75715e>#define WSIZE      4          </span><span style=color:#75715e>/* Word and header/footer size (bytes) */</span><span style=color:#75715e>
</span></span></span><span style=display:flex><span><span style=color:#75715e>#define DSIZE      8          </span><span style=color:#75715e>/* Doubleword size (bytes) */</span><span style=color:#75715e>
</span></span></span><span style=display:flex><span><span style=color:#75715e>#define CHUNKSIZE  (1&lt;&lt;12)    </span><span style=color:#75715e>/* Extend heap by this amount (bytes) */</span><span style=color:#75715e>
</span></span></span><span style=display:flex><span><span style=color:#75715e>#define MINBLOCKSIZE 16
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>
</span></span><span style=display:flex><span><span style=color:#75715e>/* Max value of 2 values */</span>
</span></span><span style=display:flex><span><span style=color:#75715e>#define MAX(x, y) ((x) &gt; (y) ? (x) : (y))
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>
</span></span><span style=display:flex><span><span style=color:#75715e>/* Pack a size and allocated bit into a word */</span>
</span></span><span style=display:flex><span><span style=color:#75715e>#define PACK(size, alloc)  ((size) | (alloc))
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>
</span></span><span style=display:flex><span><span style=color:#75715e>/* Read and write a word at address p. */</span>
</span></span><span style=display:flex><span><span style=color:#75715e>#define GET(p)       (*(unsigned int *)(p))
</span></span></span><span style=display:flex><span><span style=color:#75715e>#define PUT(p, val)  (*(unsigned int *)(p) = (val))
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>
</span></span><span style=display:flex><span><span style=color:#75715e>/* Read the size and allocated fields from address p */</span>
</span></span><span style=display:flex><span><span style=color:#75715e>#define GET_SIZE(p)        (GET(p) &amp; ~0x7)
</span></span></span><span style=display:flex><span><span style=color:#75715e>#define GET_ALLOC(p)       (GET(p) &amp; 0x1)
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>
</span></span><span style=display:flex><span><span style=color:#75715e>/* Given block ptr bp, compute address of its header and footer */</span>
</span></span><span style=display:flex><span><span style=color:#75715e>#define HDRP(bp)  ((char *)(bp) - WSIZE)
</span></span></span><span style=display:flex><span><span style=color:#75715e>#define FTRP(bp)  ((char *)(bp) + GET_SIZE(HDRP(bp)) - DSIZE)
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>
</span></span><span style=display:flex><span><span style=color:#75715e>/* Given block ptr bp, compute address of foward and back pointer field (foward and back blocks are logically linked) */</span>
</span></span><span style=display:flex><span><span style=color:#75715e>#define FDP(bp)  (*(char **)(bp + WSIZE))
</span></span></span><span style=display:flex><span><span style=color:#75715e>#define BKP(bp)  (*(char **)(bp))
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>
</span></span><span style=display:flex><span><span style=color:#75715e>/* Given block ptr bp, compute address of next and previous blocks */</span>
</span></span><span style=display:flex><span><span style=color:#75715e>#define NEXT_BLKP(bp)  ((char *)(bp) + GET_SIZE(HDRP(bp)))
</span></span></span><span style=display:flex><span><span style=color:#75715e>#define PREV_BLKP(bp)  ((char *)(bp) - GET_SIZE((char *)(bp) - DSIZE))
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>
</span></span><span style=display:flex><span><span style=color:#75715e>/* Set BK and FD field of a block by given pointer */</span>
</span></span><span style=display:flex><span><span style=color:#75715e>#define SET_BKP(bp, bkp) (BKP(bp) = bkp)
</span></span></span><span style=display:flex><span><span style=color:#75715e>#define SET_FDP(bp, fdp) (FDP(bp) = fdp)
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>
</span></span><span style=display:flex><span><span style=color:#75715e>/* Global declarations */</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>static</span> <span style=color:#66d9ef>char</span> <span style=color:#f92672>*</span>heap_listp;
</span></span><span style=display:flex><span><span style=color:#66d9ef>static</span> <span style=color:#66d9ef>char</span> <span style=color:#f92672>*</span>freelist_headp;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>/* Function prototypes for internal helper routines */</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>static</span> <span style=color:#66d9ef>void</span> <span style=color:#f92672>*</span><span style=color:#a6e22e>coalesce</span>(<span style=color:#66d9ef>void</span> <span style=color:#f92672>*</span>bp);
</span></span><span style=display:flex><span><span style=color:#66d9ef>static</span> <span style=color:#66d9ef>void</span> <span style=color:#f92672>*</span><span style=color:#a6e22e>extend_heap</span>(<span style=color:#66d9ef>size_t</span> words);
</span></span><span style=display:flex><span><span style=color:#66d9ef>static</span> <span style=color:#66d9ef>void</span> <span style=color:#f92672>*</span><span style=color:#a6e22e>find_fit</span>(<span style=color:#66d9ef>size_t</span> asize);
</span></span><span style=display:flex><span><span style=color:#66d9ef>static</span> <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>place</span>(<span style=color:#66d9ef>void</span> <span style=color:#f92672>*</span>bp, <span style=color:#66d9ef>size_t</span> asize);
</span></span><span style=display:flex><span><span style=color:#66d9ef>static</span> <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>insert</span>(<span style=color:#66d9ef>void</span> <span style=color:#f92672>*</span>bp); <span style=color:#75715e>/* insert a free block to free list */</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>static</span> <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>delete</span>(<span style=color:#66d9ef>void</span> <span style=color:#f92672>*</span>bp); <span style=color:#75715e>/* delete a free block from free list */</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>static</span> <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>mm_checkheap</span>(<span style=color:#66d9ef>int</span> verbose);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>/* 
</span></span></span><span style=display:flex><span><span style=color:#75715e> * mm_init - initialize the malloc package.
</span></span></span><span style=display:flex><span><span style=color:#75715e> */</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>int</span> <span style=color:#a6e22e>mm_init</span>(<span style=color:#66d9ef>void</span>)
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>    <span style=color:#75715e>/* Create the initial empty heap */</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> ((heap_listp <span style=color:#f92672>=</span> <span style=color:#a6e22e>mem_sbrk</span>(<span style=color:#ae81ff>4</span><span style=color:#f92672>*</span>WSIZE)) <span style=color:#f92672>==</span> (<span style=color:#66d9ef>void</span> <span style=color:#f92672>*</span>) <span style=color:#f92672>-</span><span style=color:#ae81ff>1</span>)
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> <span style=color:#f92672>-</span><span style=color:#ae81ff>1</span>;
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>PUT</span>(heap_listp, <span style=color:#ae81ff>0</span>);                             <span style=color:#75715e>/* alignment padding */</span>
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>PUT</span>(heap_listp <span style=color:#f92672>+</span> (<span style=color:#ae81ff>1</span><span style=color:#f92672>*</span>WSIZE), <span style=color:#a6e22e>PACK</span>(DSIZE, <span style=color:#ae81ff>1</span>));    <span style=color:#75715e>/* Prologue header */</span>
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>PUT</span>(heap_listp <span style=color:#f92672>+</span> (<span style=color:#ae81ff>2</span><span style=color:#f92672>*</span>WSIZE), <span style=color:#a6e22e>PACK</span>(DSIZE, <span style=color:#ae81ff>1</span>));    <span style=color:#75715e>/* Prologue footer */</span>
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>PUT</span>(heap_listp <span style=color:#f92672>+</span> (<span style=color:#ae81ff>3</span><span style=color:#f92672>*</span>WSIZE), <span style=color:#a6e22e>PACK</span>(<span style=color:#ae81ff>0</span>, <span style=color:#ae81ff>1</span>));    <span style=color:#75715e>/* Epilogue header */</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    freelist_headp <span style=color:#f92672>=</span> NULL;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>/* Extend the empty heap with a free block of CHUNKSIZE bytes */</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> (<span style=color:#a6e22e>extend_heap</span>(CHUNKSIZE<span style=color:#f92672>/</span>WSIZE) <span style=color:#f92672>==</span> NULL) <span style=color:#75715e>/* set free list head to the first free block */</span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> <span style=color:#f92672>-</span><span style=color:#ae81ff>1</span>;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> <span style=color:#ae81ff>0</span>;
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>/* 
</span></span></span><span style=display:flex><span><span style=color:#75715e> * mm_malloc - Allocate a block by incrementing the brk pointer.
</span></span></span><span style=display:flex><span><span style=color:#75715e> *             Always allocate a block whose size is a multiple of the alignment.
</span></span></span><span style=display:flex><span><span style=color:#75715e> */</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>void</span> <span style=color:#f92672>*</span><span style=color:#a6e22e>mm_malloc</span>(<span style=color:#66d9ef>size_t</span> size)
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>DBG_PRINTF</span>(<span style=color:#e6db74>&#34;Entering mm_malloc(%zu)</span><span style=color:#ae81ff>\n</span><span style=color:#e6db74>&#34;</span>, size);
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>size_t</span> asize; <span style=color:#75715e>/* Adjusted block size */</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>size_t</span> extendsize; <span style=color:#75715e>/* Amount to extend heap if not fit */</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>char</span> <span style=color:#f92672>*</span>bp;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>/* Ignore spurious requests */</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> (size <span style=color:#f92672>==</span> <span style=color:#ae81ff>0</span>) {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> NULL;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>/* Adjust block size to include overhead and alignment reqs */</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> (size <span style=color:#f92672>&lt;</span> DSIZE)
</span></span><span style=display:flex><span>        asize <span style=color:#f92672>=</span> <span style=color:#ae81ff>2</span> <span style=color:#f92672>*</span> DSIZE; <span style=color:#75715e>/* Minimum block size: WORD(HDR) + DWORD(Payload) + WORD(FTR) */</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>else</span>
</span></span><span style=display:flex><span>        asize <span style=color:#f92672>=</span> <span style=color:#a6e22e>ALIGN</span>(size <span style=color:#f92672>+</span> <span style=color:#ae81ff>8</span>);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>/* Search the free list for a fit */</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> ((bp <span style=color:#f92672>=</span> <span style=color:#a6e22e>find_fit</span>(asize)) <span style=color:#f92672>!=</span> NULL) {
</span></span><span style=display:flex><span>        <span style=color:#a6e22e>place</span>(bp, asize);
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> bp;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>/* No fit. Get more memory and place the block */</span>
</span></span><span style=display:flex><span>    extendsize <span style=color:#f92672>=</span> <span style=color:#a6e22e>MAX</span>(asize, CHUNKSIZE);
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> ((bp <span style=color:#f92672>=</span> <span style=color:#a6e22e>extend_heap</span>(extendsize <span style=color:#f92672>/</span> WSIZE)) <span style=color:#f92672>==</span> NULL)
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> NULL;
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>place</span>(bp, asize);
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> bp;
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>/*
</span></span></span><span style=display:flex><span><span style=color:#75715e> * mm_free - Freeing a block and coalesce if necessary.
</span></span></span><span style=display:flex><span><span style=color:#75715e> */</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>void</span> <span style=color:#a6e22e>mm_free</span>(<span style=color:#66d9ef>void</span> <span style=color:#f92672>*</span>bp)
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>DBG_PRINTF</span>(<span style=color:#e6db74>&#34;Entering mm_free(%p)</span><span style=color:#ae81ff>\n</span><span style=color:#e6db74>&#34;</span>, bp);
</span></span><span style=display:flex><span>    <span style=color:#75715e>/* Modify header and footer then coalesce the block and insert it into free list */</span>
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>PUT</span>(<span style=color:#a6e22e>HDRP</span>(bp), <span style=color:#a6e22e>PACK</span>(<span style=color:#a6e22e>GET_SIZE</span>(<span style=color:#a6e22e>HDRP</span>(bp)),<span style=color:#ae81ff>0</span>));
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>PUT</span>(<span style=color:#a6e22e>FTRP</span>(bp), <span style=color:#a6e22e>PACK</span>(<span style=color:#a6e22e>GET_SIZE</span>(<span style=color:#a6e22e>HDRP</span>(bp)),<span style=color:#ae81ff>0</span>));
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>coalesce</span>(bp);
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>/*
</span></span></span><span style=display:flex><span><span style=color:#75715e> * mm_realloc - Implemented simply in terms of mm_malloc and mm_free
</span></span></span><span style=display:flex><span><span style=color:#75715e> */</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>void</span> <span style=color:#f92672>*</span><span style=color:#a6e22e>mm_realloc</span>(<span style=color:#66d9ef>void</span> <span style=color:#f92672>*</span>ptr, <span style=color:#66d9ef>size_t</span> size)
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>void</span> <span style=color:#f92672>*</span>oldptr <span style=color:#f92672>=</span> ptr;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>void</span> <span style=color:#f92672>*</span>newptr;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>size_t</span> copySize;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    newptr <span style=color:#f92672>=</span> <span style=color:#a6e22e>mm_malloc</span>(size);
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> (newptr <span style=color:#f92672>==</span> NULL)
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> NULL;
</span></span><span style=display:flex><span>    size <span style=color:#f92672>=</span> <span style=color:#a6e22e>GET_SIZE</span>(<span style=color:#a6e22e>HDRP</span>(oldptr));
</span></span><span style=display:flex><span>    copySize <span style=color:#f92672>=</span> <span style=color:#a6e22e>GET_SIZE</span>(<span style=color:#a6e22e>HDRP</span>(newptr));
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> (size <span style=color:#f92672>&lt;</span> copySize)
</span></span><span style=display:flex><span>        copySize <span style=color:#f92672>=</span> size;
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>memcpy</span>(newptr, oldptr, copySize<span style=color:#f92672>-</span>WSIZE);
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>mm_free</span>(oldptr);
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> newptr;
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>/*
</span></span></span><span style=display:flex><span><span style=color:#75715e> * coalesce - Merge freed block if necessary.
</span></span></span><span style=display:flex><span><span style=color:#75715e> * Return: Pointer of the merged block.
</span></span></span><span style=display:flex><span><span style=color:#75715e> */</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>static</span> <span style=color:#66d9ef>void</span><span style=color:#f92672>*</span> <span style=color:#a6e22e>coalesce</span>(<span style=color:#66d9ef>void</span><span style=color:#f92672>*</span> bp)
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>DBG_PRINTF</span>(<span style=color:#e6db74>&#34;Entering coalesce(%p), &#34;</span>, bp);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>/* 
</span></span></span><span style=display:flex><span><span style=color:#75715e>     * We have to save our adjacent block&#39;s address.
</span></span></span><span style=display:flex><span><span style=color:#75715e>     * After `PUT(HDRP(bp), PACK(newsize ,0))` will render NEXT_BLKP(bp) nonsense.
</span></span></span><span style=display:flex><span><span style=color:#75715e>     * It&#39;s really nasty and takes me a lot of time to debug.
</span></span></span><span style=display:flex><span><span style=color:#75715e>     */</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>void</span><span style=color:#f92672>*</span> prev_bp <span style=color:#f92672>=</span> <span style=color:#a6e22e>PREV_BLKP</span>(bp);
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>void</span><span style=color:#f92672>*</span> next_bp <span style=color:#f92672>=</span> <span style=color:#a6e22e>NEXT_BLKP</span>(bp);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>size_t</span> prev_alloc <span style=color:#f92672>=</span> <span style=color:#a6e22e>GET_ALLOC</span>(<span style=color:#a6e22e>FTRP</span>(prev_bp));
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>size_t</span> next_alloc <span style=color:#f92672>=</span> <span style=color:#a6e22e>GET_ALLOC</span>(<span style=color:#a6e22e>HDRP</span>(next_bp));
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>size_t</span> current_size <span style=color:#f92672>=</span> <span style=color:#a6e22e>GET_SIZE</span>(<span style=color:#a6e22e>HDRP</span>(bp));
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>/* Case 0: no need to coalesce */</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> (prev_alloc <span style=color:#f92672>&amp;&amp;</span> next_alloc) {
</span></span><span style=display:flex><span>        <span style=color:#a6e22e>DBG_PRINTF</span>(<span style=color:#e6db74>&#34;no merge</span><span style=color:#ae81ff>\n</span><span style=color:#e6db74>&#34;</span>);
</span></span><span style=display:flex><span>        <span style=color:#a6e22e>insert</span>(bp); 
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> bp; 
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    <span style=color:#75715e>/* 
</span></span></span><span style=display:flex><span><span style=color:#75715e>     * Case 1, previous block is free
</span></span></span><span style=display:flex><span><span style=color:#75715e>     */</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>else</span> <span style=color:#66d9ef>if</span> (<span style=color:#f92672>!</span>prev_alloc <span style=color:#f92672>&amp;&amp;</span> next_alloc) {
</span></span><span style=display:flex><span>        <span style=color:#a6e22e>DBG_PRINTF</span>(<span style=color:#e6db74>&#34;merge prev(%p)</span><span style=color:#ae81ff>\n</span><span style=color:#e6db74>&#34;</span>, prev_bp);
</span></span><span style=display:flex><span>        <span style=color:#75715e>/* setup merged block */</span>
</span></span><span style=display:flex><span>        current_size <span style=color:#f92672>+=</span> <span style=color:#a6e22e>GET_SIZE</span>(<span style=color:#a6e22e>HDRP</span>(prev_bp));
</span></span><span style=display:flex><span>        <span style=color:#a6e22e>PUT</span>(<span style=color:#a6e22e>HDRP</span>(prev_bp), <span style=color:#a6e22e>PACK</span>(current_size, <span style=color:#ae81ff>0</span>));
</span></span><span style=display:flex><span>        <span style=color:#a6e22e>PUT</span>(<span style=color:#a6e22e>FTRP</span>(bp), <span style=color:#a6e22e>PACK</span>(current_size, <span style=color:#ae81ff>0</span>));
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> prev_bp;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    <span style=color:#75715e>/* 
</span></span></span><span style=display:flex><span><span style=color:#75715e>     * Case 2, next block is free, we need to delete next block from free list.
</span></span></span><span style=display:flex><span><span style=color:#75715e>     */</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>else</span> <span style=color:#66d9ef>if</span> (prev_alloc <span style=color:#f92672>&amp;&amp;</span> <span style=color:#f92672>!</span>next_alloc) {
</span></span><span style=display:flex><span>        <span style=color:#a6e22e>DBG_PRINTF</span>(<span style=color:#e6db74>&#34;merge next(%p)</span><span style=color:#ae81ff>\n</span><span style=color:#e6db74>&#34;</span>, next_bp);
</span></span><span style=display:flex><span>        <span style=color:#75715e>/* Delete next block from free list */</span>
</span></span><span style=display:flex><span>        <span style=color:#a6e22e>delete</span>(next_bp);
</span></span><span style=display:flex><span>        <span style=color:#75715e>/* setup merged block */</span>
</span></span><span style=display:flex><span>        current_size <span style=color:#f92672>+=</span> <span style=color:#a6e22e>GET_SIZE</span>(<span style=color:#a6e22e>HDRP</span>(next_bp));
</span></span><span style=display:flex><span>        <span style=color:#a6e22e>PUT</span>(<span style=color:#a6e22e>HDRP</span>(bp), <span style=color:#a6e22e>PACK</span>(current_size, <span style=color:#ae81ff>0</span>));
</span></span><span style=display:flex><span>        <span style=color:#a6e22e>PUT</span>(<span style=color:#a6e22e>FTRP</span>(bp), <span style=color:#a6e22e>PACK</span>(current_size, <span style=color:#ae81ff>0</span>));
</span></span><span style=display:flex><span>        <span style=color:#a6e22e>insert</span>(bp);
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> bp;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    <span style=color:#75715e>/* 
</span></span></span><span style=display:flex><span><span style=color:#75715e>     * Case 3, previous and next block both are free, we need to delete next block from free list.
</span></span></span><span style=display:flex><span><span style=color:#75715e>     */</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>else</span> {
</span></span><span style=display:flex><span>        <span style=color:#a6e22e>DBG_PRINTF</span>(<span style=color:#e6db74>&#34;merge prev(%p) and next(%p)</span><span style=color:#ae81ff>\n</span><span style=color:#e6db74>&#34;</span>, prev_bp, next_bp);
</span></span><span style=display:flex><span>        <span style=color:#75715e>/* Delete next block from free list */</span>
</span></span><span style=display:flex><span>        <span style=color:#a6e22e>delete</span>(next_bp);
</span></span><span style=display:flex><span>        <span style=color:#75715e>/* setup merged block */</span>
</span></span><span style=display:flex><span>        current_size <span style=color:#f92672>+=</span> <span style=color:#a6e22e>GET_SIZE</span>(<span style=color:#a6e22e>HDRP</span>(prev_bp));
</span></span><span style=display:flex><span>        current_size <span style=color:#f92672>+=</span> <span style=color:#a6e22e>GET_SIZE</span>(<span style=color:#a6e22e>FTRP</span>(next_bp));
</span></span><span style=display:flex><span>        <span style=color:#a6e22e>PUT</span>(<span style=color:#a6e22e>HDRP</span>(prev_bp), <span style=color:#a6e22e>PACK</span>(current_size, <span style=color:#ae81ff>0</span>));
</span></span><span style=display:flex><span>        <span style=color:#a6e22e>PUT</span>(<span style=color:#a6e22e>FTRP</span>(next_bp), <span style=color:#a6e22e>PACK</span>(current_size, <span style=color:#ae81ff>0</span>));
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> prev_bp;
</span></span><span style=display:flex><span>    }   
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>/*
</span></span></span><span style=display:flex><span><span style=color:#75715e> * extend_heap - Extend the heap with a free block and coalesce the new free block if necessary.
</span></span></span><span style=display:flex><span><span style=color:#75715e> * Return : new free block&#39;s payload address.
</span></span></span><span style=display:flex><span><span style=color:#75715e> */</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>static</span> <span style=color:#66d9ef>void</span> <span style=color:#f92672>*</span><span style=color:#a6e22e>extend_heap</span>(<span style=color:#66d9ef>size_t</span> words)
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>char</span> <span style=color:#f92672>*</span>bp;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>size_t</span> size;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>/* Allocate even number of words to maintain alignment */</span>
</span></span><span style=display:flex><span>    size <span style=color:#f92672>=</span> (words <span style=color:#f92672>%</span> <span style=color:#ae81ff>2</span>) <span style=color:#f92672>?</span> (words <span style=color:#f92672>+</span> <span style=color:#ae81ff>1</span>) <span style=color:#f92672>*</span> WSIZE : words <span style=color:#f92672>*</span> WSIZE;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> ((<span style=color:#66d9ef>long</span>)(bp <span style=color:#f92672>=</span> <span style=color:#a6e22e>mem_sbrk</span>(size)) <span style=color:#f92672>==</span> <span style=color:#f92672>-</span><span style=color:#ae81ff>1</span>)
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> NULL;
</span></span><span style=display:flex><span>    
</span></span><span style=display:flex><span>    <span style=color:#75715e>/* Initialize free block header/footer and the epilogue header
</span></span></span><span style=display:flex><span><span style=color:#75715e>     * After mem_srbk(size), we are always at the end of epilogue footer, 
</span></span></span><span style=display:flex><span><span style=color:#75715e>     * so we need to change the epilogue ftr to normal header and setup epilogue footer at the end of heap.
</span></span></span><span style=display:flex><span><span style=color:#75715e>     */</span>
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>PUT</span>(<span style=color:#a6e22e>HDRP</span>(bp), <span style=color:#a6e22e>PACK</span>(size, <span style=color:#ae81ff>0</span>));
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>PUT</span>(<span style=color:#a6e22e>FTRP</span>(bp), <span style=color:#a6e22e>PACK</span>(size, <span style=color:#ae81ff>0</span>));
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>PUT</span>(<span style=color:#a6e22e>HDRP</span>(<span style=color:#a6e22e>NEXT_BLKP</span>(bp)), <span style=color:#a6e22e>PACK</span>(<span style=color:#ae81ff>0</span>, <span style=color:#ae81ff>1</span>));
</span></span><span style=display:flex><span>    <span style=color:#75715e>// SET_BKP(bp, NULL);
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#75715e>// SET_FDP(bp, NULL);
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#75715e>/* Coalesce if the previous block was free */</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> <span style=color:#a6e22e>coalesce</span>(bp);
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>/* find_fit - Find freeblock that fits the request size and return it&#39;s bp */</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>static</span> <span style=color:#66d9ef>void</span> <span style=color:#f92672>*</span><span style=color:#a6e22e>find_fit</span>(<span style=color:#66d9ef>size_t</span> asize)
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>DBG_PRINTF</span>(<span style=color:#e6db74>&#34;Entering find_fit(%zu), &#34;</span>, asize);
</span></span><span style=display:flex><span>    <span style=color:#75715e>/* Free list initailzed in mm_init(), freelist_headp points to the payload of free block */</span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>/* Traverse free list */</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>for</span>(<span style=color:#66d9ef>void</span><span style=color:#f92672>*</span> current <span style=color:#f92672>=</span> freelist_headp; current <span style=color:#f92672>!=</span> NULL; current <span style=color:#f92672>=</span> <span style=color:#a6e22e>FDP</span>(current)) {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span> (<span style=color:#a6e22e>GET_SIZE</span>(<span style=color:#a6e22e>HDRP</span>(current)) <span style=color:#f92672>&gt;=</span> asize) {
</span></span><span style=display:flex><span>            <span style=color:#a6e22e>DBG_PRINTF</span>(<span style=color:#e6db74>&#34;found %p, size: %u</span><span style=color:#ae81ff>\n</span><span style=color:#e6db74>&#34;</span>, current, <span style=color:#a6e22e>GET_SIZE</span>(<span style=color:#a6e22e>HDRP</span>(current)));
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>return</span> current;
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    <span style=color:#75715e>/* Not found */</span>
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>DBG_PRINTF</span>(<span style=color:#e6db74>&#34;not found</span><span style=color:#ae81ff>\n</span><span style=color:#e6db74>&#34;</span>);
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> NULL;
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>/* place - Place requested block in current free block, split if necessary */</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>static</span> <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>place</span>(<span style=color:#66d9ef>void</span> <span style=color:#f92672>*</span>bp, <span style=color:#66d9ef>size_t</span> asize)
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>DBG_PRINTF</span>(<span style=color:#e6db74>&#34;Entering place(%p)&#34;</span>,bp);
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>delete</span>(bp);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>size_t</span> size <span style=color:#f92672>=</span> <span style=color:#a6e22e>GET_SIZE</span>(<span style=color:#a6e22e>HDRP</span>(bp));
</span></span><span style=display:flex><span>    
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> ((size <span style=color:#f92672>-</span> asize) <span style=color:#f92672>&gt;=</span> MINBLOCKSIZE)
</span></span><span style=display:flex><span>    {
</span></span><span style=display:flex><span>        <span style=color:#75715e>/* set up current block */</span>
</span></span><span style=display:flex><span>        <span style=color:#a6e22e>PUT</span>(<span style=color:#a6e22e>HDRP</span>(bp), <span style=color:#a6e22e>PACK</span>(asize, <span style=color:#ae81ff>1</span>));
</span></span><span style=display:flex><span>        <span style=color:#a6e22e>PUT</span>(<span style=color:#a6e22e>FTRP</span>(bp), <span style=color:#a6e22e>PACK</span>(asize, <span style=color:#ae81ff>1</span>));
</span></span><span style=display:flex><span>        <span style=color:#a6e22e>DBG_PRINTF</span>(<span style=color:#e6db74>&#34;split: %p and %p</span><span style=color:#ae81ff>\n</span><span style=color:#e6db74>&#34;</span>, bp, <span style=color:#a6e22e>NEXT_BLKP</span>(bp));
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>         <span style=color:#75715e>/* set up remain block */</span>
</span></span><span style=display:flex><span>        <span style=color:#a6e22e>PUT</span>(<span style=color:#a6e22e>HDRP</span>(<span style=color:#a6e22e>NEXT_BLKP</span>(bp)), <span style=color:#a6e22e>PACK</span>(size<span style=color:#f92672>-</span>asize, <span style=color:#ae81ff>0</span>));
</span></span><span style=display:flex><span>        <span style=color:#a6e22e>PUT</span>(<span style=color:#a6e22e>FTRP</span>(<span style=color:#a6e22e>NEXT_BLKP</span>(bp)), <span style=color:#a6e22e>PACK</span>(size<span style=color:#f92672>-</span>asize, <span style=color:#ae81ff>0</span>));
</span></span><span style=display:flex><span>        <span style=color:#a6e22e>coalesce</span>(<span style=color:#a6e22e>NEXT_BLKP</span>(bp));
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>else</span> {
</span></span><span style=display:flex><span>        <span style=color:#a6e22e>DBG_PRINTF</span>(<span style=color:#e6db74>&#34;no split</span><span style=color:#ae81ff>\n</span><span style=color:#e6db74>&#34;</span>);
</span></span><span style=display:flex><span>        <span style=color:#75715e>/* Waste some space, we have no other way */</span>
</span></span><span style=display:flex><span>        <span style=color:#a6e22e>PUT</span>(<span style=color:#a6e22e>HDRP</span>(bp), <span style=color:#a6e22e>PACK</span>(size, <span style=color:#ae81ff>1</span>));
</span></span><span style=display:flex><span>        <span style=color:#a6e22e>PUT</span>(<span style=color:#a6e22e>FTRP</span>(bp), <span style=color:#a6e22e>PACK</span>(size, <span style=color:#ae81ff>1</span>));
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>/*
</span></span></span><span style=display:flex><span><span style=color:#75715e> * insert - Insert given block pointer to the head of free list.
</span></span></span><span style=display:flex><span><span style=color:#75715e> * insert() is called by free() or place()
</span></span></span><span style=display:flex><span><span style=color:#75715e> */</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>static</span> <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>insert</span>(<span style=color:#66d9ef>void</span><span style=color:#f92672>*</span> bp)
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>DBG_PRINTF</span>(<span style=color:#e6db74>&#34;Entering insert(%p)</span><span style=color:#ae81ff>\n</span><span style=color:#e6db74>&#34;</span>, bp);
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> (freelist_headp <span style=color:#f92672>==</span> NULL) {
</span></span><span style=display:flex><span>        <span style=color:#a6e22e>DBG_PRINTF</span>(<span style=color:#e6db74>&#34;Free list is NULL, make %p the head of free list</span><span style=color:#ae81ff>\n</span><span style=color:#e6db74>&#34;</span>, bp);
</span></span><span style=display:flex><span>        freelist_headp <span style=color:#f92672>=</span> bp;
</span></span><span style=display:flex><span>        <span style=color:#a6e22e>SET_FDP</span>(bp, NULL);
</span></span><span style=display:flex><span>        <span style=color:#a6e22e>SET_BKP</span>(bp, NULL);
</span></span><span style=display:flex><span>        <span style=color:#a6e22e>CHECKHEAP</span>(<span style=color:#ae81ff>0</span>);
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span>;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    <span style=color:#75715e>/* Set up current block */</span>
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>SET_FDP</span>(bp, freelist_headp);
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>SET_BKP</span>(bp, <span style=color:#ae81ff>0</span>);
</span></span><span style=display:flex><span>    <span style=color:#75715e>/* Set next block */</span>
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>SET_BKP</span>(freelist_headp, bp);
</span></span><span style=display:flex><span>    <span style=color:#75715e>/* Free list head is np now */</span>
</span></span><span style=display:flex><span>    freelist_headp <span style=color:#f92672>=</span> bp;
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>CHECKHEAP</span>(<span style=color:#ae81ff>0</span>);
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span><span style=color:#75715e>/*
</span></span></span><span style=display:flex><span><span style=color:#75715e> * delete - Remove given block pointer from free list.
</span></span></span><span style=display:flex><span><span style=color:#75715e> * delete() is called by place() or coalesce();
</span></span></span><span style=display:flex><span><span style=color:#75715e> * we dont&#39; call delete() when there&#39;s no free block, so what we deleted is what we inserted.
</span></span></span><span style=display:flex><span><span style=color:#75715e> */</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>static</span> <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>delete</span>(<span style=color:#66d9ef>void</span><span style=color:#f92672>*</span> bp)
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>DBG_PRINTF</span>(<span style=color:#e6db74>&#34;Entering delete(%p)</span><span style=color:#ae81ff>\n</span><span style=color:#e6db74>&#34;</span>, bp);
</span></span><span style=display:flex><span>    <span style=color:#75715e>/* Only one free block */</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span>(<span style=color:#a6e22e>BKP</span>(bp) <span style=color:#f92672>==</span> NULL <span style=color:#f92672>&amp;&amp;</span> <span style=color:#a6e22e>FDP</span>(bp) <span style=color:#f92672>==</span> NULL) {
</span></span><span style=display:flex><span>        freelist_headp <span style=color:#f92672>=</span> NULL;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    <span style=color:#75715e>/* More than one free block, delete the first block */</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>else</span> <span style=color:#66d9ef>if</span> (<span style=color:#a6e22e>BKP</span>(bp) <span style=color:#f92672>==</span> NULL) {
</span></span><span style=display:flex><span>        <span style=color:#75715e>/* Fix free list head */</span>
</span></span><span style=display:flex><span>        <span style=color:#a6e22e>SET_BKP</span>(<span style=color:#a6e22e>FDP</span>(bp), NULL);
</span></span><span style=display:flex><span>        freelist_headp <span style=color:#f92672>=</span> <span style=color:#a6e22e>FDP</span>(bp);
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    <span style=color:#75715e>/* More than one free block, delete the last block */</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>else</span> <span style=color:#66d9ef>if</span> (<span style=color:#a6e22e>FDP</span>(bp) <span style=color:#f92672>==</span> NULL) {
</span></span><span style=display:flex><span>        <span style=color:#a6e22e>SET_FDP</span>(<span style=color:#a6e22e>BKP</span>(bp), NULL);
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    <span style=color:#75715e>/* More than two free block, delete the middle block */</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>else</span> {
</span></span><span style=display:flex><span>        <span style=color:#a6e22e>SET_FDP</span>(<span style=color:#a6e22e>BKP</span>(bp), <span style=color:#a6e22e>FDP</span>(bp));
</span></span><span style=display:flex><span>        <span style=color:#a6e22e>SET_BKP</span>(<span style=color:#a6e22e>FDP</span>(bp), <span style=color:#a6e22e>BKP</span>(bp));
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>CHECKHEAP</span>(<span style=color:#ae81ff>0</span>);
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>static</span> <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>mm_checkheap</span>(<span style=color:#66d9ef>int</span> verbose)
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>DBG_PRINTF</span>(<span style=color:#e6db74>&#34;---------------CHECK HEAP START---------------------</span><span style=color:#ae81ff>\n</span><span style=color:#e6db74>&#34;</span>);
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>DBG_PRINTF</span>(<span style=color:#e6db74>&#34;freelist_headp: %p</span><span style=color:#ae81ff>\n</span><span style=color:#e6db74>&#34;</span>, freelist_headp);
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> (freelist_headp) {
</span></span><span style=display:flex><span>        <span style=color:#a6e22e>DBG_PRINTF</span>(<span style=color:#e6db74>&#34;Free List: %p&lt;-&#34;</span>, <span style=color:#a6e22e>BKP</span>(freelist_headp));
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>for</span> (<span style=color:#66d9ef>char</span> <span style=color:#f92672>*</span> tmp <span style=color:#f92672>=</span> freelist_headp; tmp <span style=color:#f92672>!=</span> NULL; tmp <span style=color:#f92672>=</span> <span style=color:#a6e22e>FDP</span>(tmp)) {
</span></span><span style=display:flex><span>            <span style=color:#a6e22e>DBG_PRINTF</span>(<span style=color:#e6db74>&#34;%p(size: %u)-&gt;&#34;</span>, tmp, <span style=color:#a6e22e>GET_SIZE</span>(<span style=color:#a6e22e>HDRP</span>(tmp)));
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>        <span style=color:#a6e22e>DBG_PRINTF</span>(<span style=color:#e6db74>&#34;%p</span><span style=color:#ae81ff>\n</span><span style=color:#e6db74>&#34;</span>, NULL);
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>DBG_PRINTF</span>(<span style=color:#e6db74>&#34;---------------CHECK HEAP END----------------------</span><span style=color:#ae81ff>\n</span><span style=color:#e6db74>&#34;</span>);
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h3 id=实现三segregated-free-list分离式空闲链表>实现三：Segregated Free List（分离式空闲链表）
<a class=header-anchor href=#%e5%ae%9e%e7%8e%b0%e4%b8%89segregated-free-list%e5%88%86%e7%a6%bb%e5%bc%8f%e7%a9%ba%e9%97%b2%e9%93%be%e8%a1%a8></a></h3><h4 id=实现代码-2>实现代码
<a class=header-anchor href=#%e5%ae%9e%e7%8e%b0%e4%bb%a3%e7%a0%81-2></a></h4><p>得分84，还有优化的空间</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-fallback data-lang=fallback><span style=display:flex><span>Results for mm malloc:
</span></span><span style=display:flex><span>trace  valid  util     ops      secs  Kops
</span></span><span style=display:flex><span> 0       yes   98%    5694  0.000302 18836
</span></span><span style=display:flex><span> 1       yes   94%    5848  0.000307 19061
</span></span><span style=display:flex><span> 2       yes   98%    6648  0.000374 17780
</span></span><span style=display:flex><span> 3       yes   99%    5380  0.000290 18526
</span></span><span style=display:flex><span> 4       yes   66%   14400  0.000525 27439
</span></span><span style=display:flex><span> 5       yes   89%    4800  0.001009  4757
</span></span><span style=display:flex><span> 6       yes   86%    4800  0.001024  4688
</span></span><span style=display:flex><span> 7       yes   55%   12000  0.007099  1690
</span></span><span style=display:flex><span> 8       yes   51%   24000  0.027033   888
</span></span><span style=display:flex><span> 9       yes   30%   14401  0.032619   441
</span></span><span style=display:flex><span>10       yes   34%   14401  0.002412  5970
</span></span><span style=display:flex><span>Total          73%  112372  0.072994  1539
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>Perf index = 44 (util) + 40 (thru) = 84/100
</span></span></code></pre></div><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=display:flex><span><span style=color:#75715e>/*
</span></span></span><span style=display:flex><span><span style=color:#75715e>   mm.c - Malloc package using segregated free list.
</span></span></span><span style=display:flex><span><span style=color:#75715e>
</span></span></span><span style=display:flex><span><span style=color:#75715e>   Chunk details:
</span></span></span><span style=display:flex><span><span style=color:#75715e>    Chunks of memory are maintained using a `boundary tag&#39; method as
</span></span></span><span style=display:flex><span><span style=color:#75715e>    described in e.g., Knuth or Standish.  (See the paper by Paul
</span></span></span><span style=display:flex><span><span style=color:#75715e>    Wilson ftp://ftp.cs.utexas.edu/pub/garbage/allocsrv.ps for a
</span></span></span><span style=display:flex><span><span style=color:#75715e>    survey of such techniques.)  Sizes of free chunks are stored both
</span></span></span><span style=display:flex><span><span style=color:#75715e>    in the front of each chunk and at the end.  This makes
</span></span></span><span style=display:flex><span><span style=color:#75715e>    consolidating fragmented chunks into bigger chunks very fast.  The
</span></span></span><span style=display:flex><span><span style=color:#75715e>    size fields also hold bits representing whether chunks are free or
</span></span></span><span style=display:flex><span><span style=color:#75715e>    in use.
</span></span></span><span style=display:flex><span><span style=color:#75715e>
</span></span></span><span style=display:flex><span><span style=color:#75715e>    An allocated chunk looks like this:
</span></span></span><span style=display:flex><span><span style=color:#75715e>    
</span></span></span><span style=display:flex><span><span style=color:#75715e>        header-&gt; +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-
</span></span></span><span style=display:flex><span><span style=color:#75715e>        |             Size of chunk, in bytes                         |A|
</span></span></span><span style=display:flex><span><span style=color:#75715e>        mem-&gt; +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
</span></span></span><span style=display:flex><span><span style=color:#75715e>        |             User data starts here...                          .
</span></span></span><span style=display:flex><span><span style=color:#75715e>        .                                                               .
</span></span></span><span style=display:flex><span><span style=color:#75715e>        .                                                               .
</span></span></span><span style=display:flex><span><span style=color:#75715e>        .                                                               |
</span></span></span><span style=display:flex><span><span style=color:#75715e>        footer-&gt; +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-
</span></span></span><span style=display:flex><span><span style=color:#75715e>        |             Same as header(`boundary tag`)                  |A|
</span></span></span><span style=display:flex><span><span style=color:#75715e>        +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
</span></span></span><span style=display:flex><span><span style=color:#75715e>
</span></span></span><span style=display:flex><span><span style=color:#75715e>    &#34;header&#34; is the front of the chunk for the purpose of most of the
</span></span></span><span style=display:flex><span><span style=color:#75715e>    malloc code, but &#34;mem&#34; is the pointer that is returned to the user. 
</span></span></span><span style=display:flex><span><span style=color:#75715e>
</span></span></span><span style=display:flex><span><span style=color:#75715e>    Chunks always begin on even word boundaries, so the mem portion
</span></span></span><span style=display:flex><span><span style=color:#75715e>    (which is returned to the user) is also on an even word boundary, and
</span></span></span><span style=display:flex><span><span style=color:#75715e>    thus at least double-word aligned.
</span></span></span><span style=display:flex><span><span style=color:#75715e>
</span></span></span><span style=display:flex><span><span style=color:#75715e>    Free chunks are stored in doubly-linked lists, and look like this:
</span></span></span><span style=display:flex><span><span style=color:#75715e>
</span></span></span><span style=display:flex><span><span style=color:#75715e>        header-&gt; +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-
</span></span></span><span style=display:flex><span><span style=color:#75715e>        |             Size of chunk, in bytes                         |A|
</span></span></span><span style=display:flex><span><span style=color:#75715e>        mem-&gt; +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
</span></span></span><span style=display:flex><span><span style=color:#75715e>        |             Forward pointer to next chunk in free list        |
</span></span></span><span style=display:flex><span><span style=color:#75715e>        +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
</span></span></span><span style=display:flex><span><span style=color:#75715e>        |             Back pointer to previous chunk in free list       |
</span></span></span><span style=display:flex><span><span style=color:#75715e>        +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
</span></span></span><span style=display:flex><span><span style=color:#75715e>        |             Unused space (may be 0 bytes long)                .
</span></span></span><span style=display:flex><span><span style=color:#75715e>        .                                                               .
</span></span></span><span style=display:flex><span><span style=color:#75715e>        .                                                               |
</span></span></span><span style=display:flex><span><span style=color:#75715e>        footer-&gt; +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-
</span></span></span><span style=display:flex><span><span style=color:#75715e>        |             Same as header(`boundary tag`)                  |A|
</span></span></span><span style=display:flex><span><span style=color:#75715e>        +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
</span></span></span><span style=display:flex><span><span style=color:#75715e>    
</span></span></span><span style=display:flex><span><span style=color:#75715e>    The A (ALLOCATED) bit is set for prologue and epilogue block to help
</span></span></span><span style=display:flex><span><span style=color:#75715e>    determine block&#39;s boundary.
</span></span></span><span style=display:flex><span><span style=color:#75715e>    Prologue and epilogue block&#39;s size are set to 0.
</span></span></span><span style=display:flex><span><span style=color:#75715e>   
</span></span></span><span style=display:flex><span><span style=color:#75715e>   Heap structure:
</span></span></span><span style=display:flex><span><span style=color:#75715e>        heap start-&gt; +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-
</span></span></span><span style=display:flex><span><span style=color:#75715e>        |                 4 btes padding                  |
</span></span></span><span style=display:flex><span><span style=color:#75715e>        free list heads-&gt; +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
</span></span></span><span style=display:flex><span><span style=color:#75715e>        | Free list&#39;s head address(request size &lt;= 8)     |
</span></span></span><span style=display:flex><span><span style=color:#75715e>        +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
</span></span></span><span style=display:flex><span><span style=color:#75715e>        | Free list&#39;s head address(request size &lt;= 16)    |
</span></span></span><span style=display:flex><span><span style=color:#75715e>        +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
</span></span></span><span style=display:flex><span><span style=color:#75715e>        |                                                 .
</span></span></span><span style=display:flex><span><span style=color:#75715e>        .    Same as above, request size &lt;= power of 2    .
</span></span></span><span style=display:flex><span><span style=color:#75715e>        .                                                 |
</span></span></span><span style=display:flex><span><span style=color:#75715e>        +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
</span></span></span><span style=display:flex><span><span style=color:#75715e>        | Free list&#39;s head address(request size &gt; 4096)   |
</span></span></span><span style=display:flex><span><span style=color:#75715e>        prologue header-&gt; +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
</span></span></span><span style=display:flex><span><span style=color:#75715e>        |             Size of chunk, in bytes           |A|
</span></span></span><span style=display:flex><span><span style=color:#75715e>        prologue footer-&gt;-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
</span></span></span><span style=display:flex><span><span style=color:#75715e>        |             Size of chunk, in bytes           |A|
</span></span></span><span style=display:flex><span><span style=color:#75715e>        free and allocated chunks-&gt; +-+-+-+-+-+-+-+-+-+-+-+
</span></span></span><span style=display:flex><span><span style=color:#75715e>        |                                                 .
</span></span></span><span style=display:flex><span><span style=color:#75715e>        .                                                 .
</span></span></span><span style=display:flex><span><span style=color:#75715e>        .                                                 |
</span></span></span><span style=display:flex><span><span style=color:#75715e>        epilogue footer-&gt;-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
</span></span></span><span style=display:flex><span><span style=color:#75715e>        |             Size of chunk, in bytes           |A|
</span></span></span><span style=display:flex><span><span style=color:#75715e>        +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
</span></span></span><span style=display:flex><span><span style=color:#75715e>    
</span></span></span><span style=display:flex><span><span style=color:#75715e>    The free list head stores the starting address of each
</span></span></span><span style=display:flex><span><span style=color:#75715e>    free list for differnt size classes, from lower than 8
</span></span></span><span style=display:flex><span><span style=color:#75715e>    byts to bigger than 4096 bytes.
</span></span></span><span style=display:flex><span><span style=color:#75715e>    We have 10 free list entry, so no padding is needed.
</span></span></span><span style=display:flex><span><span style=color:#75715e> */</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>#include</span> <span style=color:#75715e>&lt;stddef.h&gt;</span><span style=color:#75715e>
</span></span></span><span style=display:flex><span><span style=color:#75715e>#include</span> <span style=color:#75715e>&lt;stdio.h&gt;</span><span style=color:#75715e>
</span></span></span><span style=display:flex><span><span style=color:#75715e>#include</span> <span style=color:#75715e>&lt;stdlib.h&gt;</span><span style=color:#75715e>
</span></span></span><span style=display:flex><span><span style=color:#75715e>#include</span> <span style=color:#75715e>&lt;assert.h&gt;</span><span style=color:#75715e>
</span></span></span><span style=display:flex><span><span style=color:#75715e>#include</span> <span style=color:#75715e>&lt;unistd.h&gt;</span><span style=color:#75715e>
</span></span></span><span style=display:flex><span><span style=color:#75715e>#include</span> <span style=color:#75715e>&lt;string.h&gt;</span><span style=color:#75715e>
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>
</span></span><span style=display:flex><span><span style=color:#75715e>#include</span> <span style=color:#75715e>&#34;mm.h&#34;</span><span style=color:#75715e>
</span></span></span><span style=display:flex><span><span style=color:#75715e>#include</span> <span style=color:#75715e>&#34;memlib.h&#34;</span><span style=color:#75715e>
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>
</span></span><span style=display:flex><span><span style=color:#75715e>/*********************************************************
</span></span></span><span style=display:flex><span><span style=color:#75715e> * NOTE TO STUDENTS: Before you do anything else, please
</span></span></span><span style=display:flex><span><span style=color:#75715e> * provide your team information in the following struct.
</span></span></span><span style=display:flex><span><span style=color:#75715e> ********************************************************/</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>team_t</span> team <span style=color:#f92672>=</span> {
</span></span><span style=display:flex><span>    <span style=color:#75715e>/* Team name */</span>
</span></span><span style=display:flex><span>    <span style=color:#e6db74>&#34;ateam&#34;</span>,
</span></span><span style=display:flex><span>    <span style=color:#75715e>/* First member&#39;s full name */</span>
</span></span><span style=display:flex><span>    <span style=color:#e6db74>&#34;Harry Bovik&#34;</span>,
</span></span><span style=display:flex><span>    <span style=color:#75715e>/* First member&#39;s email address */</span>
</span></span><span style=display:flex><span>    <span style=color:#e6db74>&#34;bovik@cs.cmu.edu&#34;</span>,
</span></span><span style=display:flex><span>    <span style=color:#75715e>/* Second member&#39;s full name (leave blank if none) */</span>
</span></span><span style=display:flex><span>    <span style=color:#e6db74>&#34;&#34;</span>,
</span></span><span style=display:flex><span>    <span style=color:#75715e>/* Second member&#39;s email address (leave blank if none) */</span>
</span></span><span style=display:flex><span>    <span style=color:#e6db74>&#34;&#34;</span>
</span></span><span style=display:flex><span>};
</span></span><span style=display:flex><span><span style=color:#75715e>/*
</span></span></span><span style=display:flex><span><span style=color:#75715e>  Debugging macros:
</span></span></span><span style=display:flex><span><span style=color:#75715e>*/</span>
</span></span><span style=display:flex><span><span style=color:#75715e>#define DEBUG 0
</span></span></span><span style=display:flex><span><span style=color:#75715e>#define HEAP_CHECK 0
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>
</span></span><span style=display:flex><span><span style=color:#75715e>#if DEBUG == 1
</span></span></span><span style=display:flex><span><span style=color:#75715e># define DBG_PRINTF(...) printf(__VA_ARGS__)
</span></span></span><span style=display:flex><span><span style=color:#75715e>#else
</span></span></span><span style=display:flex><span><span style=color:#75715e># define DBG_PRINTF(...)
</span></span></span><span style=display:flex><span><span style=color:#75715e>#endif
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>
</span></span><span style=display:flex><span><span style=color:#75715e>#if HEAP_CHECK == 1
</span></span></span><span style=display:flex><span><span style=color:#75715e>#define CHECKHEAP(verbose) mm_checkheap(verbose)
</span></span></span><span style=display:flex><span><span style=color:#75715e>#else
</span></span></span><span style=display:flex><span><span style=color:#75715e>#define CHECKHEAP(verbose) 
</span></span></span><span style=display:flex><span><span style=color:#75715e>#endif
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>/* 8 bytes alignment in 32bit mode */</span>
</span></span><span style=display:flex><span><span style=color:#75715e>#define ALIGNMENT 8
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>
</span></span><span style=display:flex><span><span style=color:#75715e>/* Rounds up to the nearest multiple of ALIGNMENT */</span>
</span></span><span style=display:flex><span><span style=color:#75715e>#define ALIGN(size) (((size) + (ALIGNMENT-1)) &amp; ~0x7)
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>
</span></span><span style=display:flex><span><span style=color:#75715e>//* Basic constants and macros: */
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#75715e>#define WSIZE      4          </span><span style=color:#75715e>/* Word and header/footer size (bytes) */</span><span style=color:#75715e>
</span></span></span><span style=display:flex><span><span style=color:#75715e>#define DSIZE      8          </span><span style=color:#75715e>/* Doubleword size (bytes) */</span><span style=color:#75715e>
</span></span></span><span style=display:flex><span><span style=color:#75715e>#define CHUNKSIZE  (1&lt;&lt;12)    </span><span style=color:#75715e>/* Extend heap by this amount (bytes) */</span><span style=color:#75715e>
</span></span></span><span style=display:flex><span><span style=color:#75715e>#define MINBLOCKSIZE 16       </span><span style=color:#75715e>/* Minimum block size: WORD(HDR) + WORD(FDP) + WORD(BKP) + WORD(FTR) */</span><span style=color:#75715e>
</span></span></span><span style=display:flex><span><span style=color:#75715e>#define ALLOCATED 1
</span></span></span><span style=display:flex><span><span style=color:#75715e>#define UNALLOCATED 0
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>
</span></span><span style=display:flex><span><span style=color:#75715e>/* Max value of 2 values */</span>
</span></span><span style=display:flex><span><span style=color:#75715e>#define MAX(x, y) ((x) &gt; (y) ? (x) : (y))
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>
</span></span><span style=display:flex><span><span style=color:#75715e>/* Pack a size and allocated bit into a word */</span>
</span></span><span style=display:flex><span><span style=color:#75715e>#define PACK(size, alloc)  ((size) | (alloc))
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>
</span></span><span style=display:flex><span><span style=color:#75715e>/* Read and write a word at address p. */</span>
</span></span><span style=display:flex><span><span style=color:#75715e>#define GET(p)       (*(unsigned int *)(p))
</span></span></span><span style=display:flex><span><span style=color:#75715e>#define PUT(p, val)  (*(unsigned int *)(p) = (val))
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>
</span></span><span style=display:flex><span><span style=color:#75715e>/* Read the size and allocated fields from address p */</span>
</span></span><span style=display:flex><span><span style=color:#75715e>#define GET_SIZE(p)   (GET(p) &amp; ~0x7)
</span></span></span><span style=display:flex><span><span style=color:#75715e>#define GET_ALLOC(p)  (GET(p) &amp; 0x1)
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>
</span></span><span style=display:flex><span><span style=color:#75715e>/* Given block ptr bp, compute address of its header and footer */</span>
</span></span><span style=display:flex><span><span style=color:#75715e>#define HDRP(bp)  ((char *)(bp) - WSIZE)
</span></span></span><span style=display:flex><span><span style=color:#75715e>#define FTRP(bp)  ((char *)(bp) + GET_SIZE(HDRP(bp)) - DSIZE)
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>
</span></span><span style=display:flex><span><span style=color:#75715e>/* Given block ptr bp, get value of foward and back pointer of that chunk (note those are different from HDRP() adn FTRP()) */</span>
</span></span><span style=display:flex><span><span style=color:#75715e>#define FDP(bp)  (*(char **)(bp))
</span></span></span><span style=display:flex><span><span style=color:#75715e>#define BKP(bp)  (*(char **)(bp + WSIZE))
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>
</span></span><span style=display:flex><span><span style=color:#75715e>/* Given block ptr bp, set forward and back pointer&#39;s value of that block by given value*/</span>
</span></span><span style=display:flex><span><span style=color:#75715e>#define SET_FDP(bp, fdp) (FDP(bp) = fdp)
</span></span></span><span style=display:flex><span><span style=color:#75715e>#define SET_BKP(bp, bkp) (BKP(bp) = bkp)
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>
</span></span><span style=display:flex><span><span style=color:#75715e>/* Given block ptr bp, compute address of next and previous blocks */</span>
</span></span><span style=display:flex><span><span style=color:#75715e>#define NEXT_BLKP(bp)  ((char *)(bp) + GET_SIZE(HDRP(bp)))
</span></span></span><span style=display:flex><span><span style=color:#75715e>#define PREV_BLKP(bp)  ((char *)(bp) - GET_SIZE((char *)(bp) - DSIZE))
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>
</span></span><span style=display:flex><span><span style=color:#75715e>/* Given block size, compute the free list offset */</span>
</span></span><span style=display:flex><span><span style=color:#75715e>#define LIST_OFFSET(size) \
</span></span></span><span style=display:flex><span><span style=color:#75715e>    (size &lt;= 16   ? 0 :\
</span></span></span><span style=display:flex><span><span style=color:#75715e>     size &lt;= 32   ? 1 :\
</span></span></span><span style=display:flex><span><span style=color:#75715e>     size &lt;= 64   ? 2 :\
</span></span></span><span style=display:flex><span><span style=color:#75715e>     size &lt;= 128  ? 3 :\
</span></span></span><span style=display:flex><span><span style=color:#75715e>     size &lt;= 256  ? 4 :\
</span></span></span><span style=display:flex><span><span style=color:#75715e>     size &lt;= 512  ? 5 :\
</span></span></span><span style=display:flex><span><span style=color:#75715e>     size &lt;= 1024 ? 6 :\
</span></span></span><span style=display:flex><span><span style=color:#75715e>     size &lt;= 2048 ? 7 :\
</span></span></span><span style=display:flex><span><span style=color:#75715e>     size &lt;= 4096 ? 8 :\
</span></span></span><span style=display:flex><span><span style=color:#75715e>     9)
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>
</span></span><span style=display:flex><span><span style=color:#75715e>/* Global declarations */</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>static</span> <span style=color:#66d9ef>char</span> <span style=color:#f92672>*</span>heap_listp;
</span></span><span style=display:flex><span><span style=color:#66d9ef>static</span> <span style=color:#66d9ef>char</span> <span style=color:#f92672>*</span>seglist_start;
</span></span><span style=display:flex><span><span style=color:#66d9ef>static</span> <span style=color:#66d9ef>char</span> <span style=color:#f92672>*</span>freelist_headp;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>/* Function prototypes for internal helper routines */</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>static</span> <span style=color:#66d9ef>void</span> <span style=color:#f92672>*</span><span style=color:#a6e22e>coalesce</span>(<span style=color:#66d9ef>void</span> <span style=color:#f92672>*</span>bp);
</span></span><span style=display:flex><span><span style=color:#66d9ef>static</span> <span style=color:#66d9ef>void</span> <span style=color:#f92672>*</span><span style=color:#a6e22e>extend_heap</span>(<span style=color:#66d9ef>size_t</span> words);
</span></span><span style=display:flex><span><span style=color:#66d9ef>static</span> <span style=color:#66d9ef>void</span> <span style=color:#f92672>*</span><span style=color:#a6e22e>find_fit</span>(<span style=color:#66d9ef>size_t</span> asize);
</span></span><span style=display:flex><span><span style=color:#66d9ef>static</span> <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>place</span>(<span style=color:#66d9ef>void</span> <span style=color:#f92672>*</span>bp, <span style=color:#66d9ef>size_t</span> asize);
</span></span><span style=display:flex><span><span style=color:#66d9ef>static</span> <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>insert</span>(<span style=color:#66d9ef>void</span> <span style=color:#f92672>*</span>bp); <span style=color:#75715e>/* insert a free block to free list */</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>static</span> <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>delete</span>(<span style=color:#66d9ef>void</span> <span style=color:#f92672>*</span>bp); <span style=color:#75715e>/* delete a free block from free list */</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>static</span> <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>mm_checkheap</span>(<span style=color:#66d9ef>int</span> verbose);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>/* 
</span></span></span><span style=display:flex><span><span style=color:#75715e> * mm_init - initialize the malloc package.
</span></span></span><span style=display:flex><span><span style=color:#75715e> */</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>int</span> <span style=color:#a6e22e>mm_init</span>(<span style=color:#66d9ef>void</span>)
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>    <span style=color:#75715e>/* Create the initial empty heap */</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> ((heap_listp <span style=color:#f92672>=</span> <span style=color:#a6e22e>mem_sbrk</span>(<span style=color:#ae81ff>14</span><span style=color:#f92672>*</span>WSIZE)) <span style=color:#f92672>==</span> (<span style=color:#66d9ef>void</span> <span style=color:#f92672>*</span>) <span style=color:#f92672>-</span><span style=color:#ae81ff>1</span>)
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> <span style=color:#f92672>-</span><span style=color:#ae81ff>1</span>;
</span></span><span style=display:flex><span>    
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>PUT</span>(heap_listp, <span style=color:#ae81ff>0</span>);                 <span style=color:#75715e>/* Padding for alignment, user memory sits at 14*4 = 48 Bytes after heap start*/</span>
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>PUT</span>(heap_listp <span style=color:#f92672>+</span> (<span style=color:#ae81ff>1</span><span style=color:#f92672>*</span>WSIZE), <span style=color:#ae81ff>0</span>);     <span style=color:#75715e>/* Block size &lt;= 16   */</span>
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>PUT</span>(heap_listp <span style=color:#f92672>+</span> (<span style=color:#ae81ff>2</span><span style=color:#f92672>*</span>WSIZE), <span style=color:#ae81ff>0</span>);     <span style=color:#75715e>/* Block size &lt;= 32   */</span>
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>PUT</span>(heap_listp <span style=color:#f92672>+</span> (<span style=color:#ae81ff>3</span><span style=color:#f92672>*</span>WSIZE), <span style=color:#ae81ff>0</span>);     <span style=color:#75715e>/* Block size &lt;= 64   */</span>
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>PUT</span>(heap_listp <span style=color:#f92672>+</span> (<span style=color:#ae81ff>4</span><span style=color:#f92672>*</span>WSIZE), <span style=color:#ae81ff>0</span>);     <span style=color:#75715e>/* Block size &lt;= 128  */</span>
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>PUT</span>(heap_listp <span style=color:#f92672>+</span> (<span style=color:#ae81ff>5</span><span style=color:#f92672>*</span>WSIZE), <span style=color:#ae81ff>0</span>);     <span style=color:#75715e>/* Block size &lt;= 256  */</span>
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>PUT</span>(heap_listp <span style=color:#f92672>+</span> (<span style=color:#ae81ff>6</span><span style=color:#f92672>*</span>WSIZE), <span style=color:#ae81ff>0</span>);     <span style=color:#75715e>/* Block size &lt;= 512  */</span>
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>PUT</span>(heap_listp <span style=color:#f92672>+</span> (<span style=color:#ae81ff>7</span><span style=color:#f92672>*</span>WSIZE), <span style=color:#ae81ff>0</span>);     <span style=color:#75715e>/* Block size &lt;= 1024 */</span>
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>PUT</span>(heap_listp <span style=color:#f92672>+</span> (<span style=color:#ae81ff>8</span><span style=color:#f92672>*</span>WSIZE), <span style=color:#ae81ff>0</span>);     <span style=color:#75715e>/* Block size &lt;= 2048 */</span>
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>PUT</span>(heap_listp <span style=color:#f92672>+</span> (<span style=color:#ae81ff>9</span><span style=color:#f92672>*</span>WSIZE), <span style=color:#ae81ff>0</span>);     <span style=color:#75715e>/* Block size &lt;= 4096 */</span>
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>PUT</span>(heap_listp <span style=color:#f92672>+</span> (<span style=color:#ae81ff>10</span><span style=color:#f92672>*</span>WSIZE), <span style=color:#ae81ff>0</span>);    <span style=color:#75715e>/* Block size &gt;  4096 */</span>
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>PUT</span>(heap_listp <span style=color:#f92672>+</span> (<span style=color:#ae81ff>11</span><span style=color:#f92672>*</span>WSIZE), <span style=color:#a6e22e>PACK</span>(DSIZE, <span style=color:#ae81ff>1</span>));    <span style=color:#75715e>/* Prologue header */</span>
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>PUT</span>(heap_listp <span style=color:#f92672>+</span> (<span style=color:#ae81ff>12</span><span style=color:#f92672>*</span>WSIZE), <span style=color:#a6e22e>PACK</span>(DSIZE, <span style=color:#ae81ff>1</span>));    <span style=color:#75715e>/* Prologue footer */</span>
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>PUT</span>(heap_listp <span style=color:#f92672>+</span> (<span style=color:#ae81ff>13</span><span style=color:#f92672>*</span>WSIZE), <span style=color:#a6e22e>PACK</span>(<span style=color:#ae81ff>0</span>, <span style=color:#ae81ff>1</span>));        <span style=color:#75715e>/* Epilogue header */</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    seglist_start <span style=color:#f92672>=</span> heap_listp <span style=color:#f92672>+</span> WSIZE;
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>DBG_PRINTF</span>(<span style=color:#e6db74>&#34;seglist_start: %p</span><span style=color:#ae81ff>\n</span><span style=color:#e6db74>&#34;</span>, seglist_start);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>/* Extend the empty heap with a free block of CHUNKSIZE bytes */</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> (<span style=color:#a6e22e>extend_heap</span>(CHUNKSIZE<span style=color:#f92672>/</span>WSIZE) <span style=color:#f92672>==</span> NULL) <span style=color:#75715e>/* set free list head to the first free block */</span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> <span style=color:#f92672>-</span><span style=color:#ae81ff>1</span>;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> <span style=color:#ae81ff>0</span>;
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>/* 
</span></span></span><span style=display:flex><span><span style=color:#75715e> * mm_malloc - Allocate a block by incrementing the brk pointer.
</span></span></span><span style=display:flex><span><span style=color:#75715e> *             Always allocate a block whose size is a multiple of the alignment.
</span></span></span><span style=display:flex><span><span style=color:#75715e> */</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>void</span> <span style=color:#f92672>*</span><span style=color:#a6e22e>mm_malloc</span>(<span style=color:#66d9ef>size_t</span> size)
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>DBG_PRINTF</span>(<span style=color:#e6db74>&#34;Entering mm_malloc(%zu)</span><span style=color:#ae81ff>\n</span><span style=color:#e6db74>&#34;</span>, size);
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>CHECKHEAP</span>(<span style=color:#ae81ff>0</span>);
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>size_t</span> asize; <span style=color:#75715e>/* Adjusted block size */</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>size_t</span> extendsize; <span style=color:#75715e>/* Amount to extend heap if not fit */</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>char</span> <span style=color:#f92672>*</span>bp;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>/* Ignore spurious requests */</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> (size <span style=color:#f92672>==</span> <span style=color:#ae81ff>0</span>) {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> NULL;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>/* Adjust block size to include overhead and alignment reqs */</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> (size <span style=color:#f92672>&lt;</span> DSIZE)
</span></span><span style=display:flex><span>        asize <span style=color:#f92672>=</span> <span style=color:#ae81ff>2</span> <span style=color:#f92672>*</span> DSIZE; <span style=color:#75715e>/* Minimum block size: WORD(HDR) + DWORD(Payload) + WORD(FTR) */</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>else</span>
</span></span><span style=display:flex><span>        asize <span style=color:#f92672>=</span> <span style=color:#a6e22e>ALIGN</span>(size <span style=color:#f92672>+</span> <span style=color:#ae81ff>8</span>);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>/* Search the free list for a fit */</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> ((bp <span style=color:#f92672>=</span> <span style=color:#a6e22e>find_fit</span>(asize)) <span style=color:#f92672>!=</span> NULL) {
</span></span><span style=display:flex><span>        <span style=color:#a6e22e>place</span>(bp, asize);
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> bp;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>/* No fit. Get more memory and place the block */</span>
</span></span><span style=display:flex><span>    extendsize <span style=color:#f92672>=</span> <span style=color:#a6e22e>MAX</span>(asize, CHUNKSIZE);
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> ((bp <span style=color:#f92672>=</span> <span style=color:#a6e22e>extend_heap</span>(extendsize <span style=color:#f92672>/</span> WSIZE)) <span style=color:#f92672>==</span> NULL)
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> NULL;
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>place</span>(bp, asize);
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> bp;
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>/*
</span></span></span><span style=display:flex><span><span style=color:#75715e> * mm_free - Freeing a block and coalesce if necessary.
</span></span></span><span style=display:flex><span><span style=color:#75715e> */</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>void</span> <span style=color:#a6e22e>mm_free</span>(<span style=color:#66d9ef>void</span> <span style=color:#f92672>*</span>bp)
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>DBG_PRINTF</span>(<span style=color:#e6db74>&#34;Entering mm_free(%p)</span><span style=color:#ae81ff>\n</span><span style=color:#e6db74>&#34;</span>, bp);
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>CHECKHEAP</span>(<span style=color:#ae81ff>0</span>);
</span></span><span style=display:flex><span>    <span style=color:#75715e>/* Modify header and footer then coalesce the block and insert it into free list */</span>
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>PUT</span>(<span style=color:#a6e22e>HDRP</span>(bp), <span style=color:#a6e22e>PACK</span>(<span style=color:#a6e22e>GET_SIZE</span>(<span style=color:#a6e22e>HDRP</span>(bp)),<span style=color:#ae81ff>0</span>));
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>PUT</span>(<span style=color:#a6e22e>FTRP</span>(bp), <span style=color:#a6e22e>PACK</span>(<span style=color:#a6e22e>GET_SIZE</span>(<span style=color:#a6e22e>HDRP</span>(bp)),<span style=color:#ae81ff>0</span>));
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>coalesce</span>(bp);
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>/*
</span></span></span><span style=display:flex><span><span style=color:#75715e> * mm_realloc - Implemented simply in terms of mm_malloc and mm_free
</span></span></span><span style=display:flex><span><span style=color:#75715e> */</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>void</span> <span style=color:#f92672>*</span><span style=color:#a6e22e>mm_realloc</span>(<span style=color:#66d9ef>void</span> <span style=color:#f92672>*</span>ptr, <span style=color:#66d9ef>size_t</span> size)
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>DBG_PRINTF</span>(<span style=color:#e6db74>&#34;Entering mm_realloc(%p, %zu)</span><span style=color:#ae81ff>\n</span><span style=color:#e6db74>&#34;</span>, ptr, size);
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>CHECKHEAP</span>(<span style=color:#ae81ff>0</span>);
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>void</span> <span style=color:#f92672>*</span>oldptr <span style=color:#f92672>=</span> ptr;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>void</span> <span style=color:#f92672>*</span>newptr;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>size_t</span> copySize;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    newptr <span style=color:#f92672>=</span> <span style=color:#a6e22e>mm_malloc</span>(size);
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> (newptr <span style=color:#f92672>==</span> NULL)
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> NULL;
</span></span><span style=display:flex><span>    size <span style=color:#f92672>=</span> <span style=color:#a6e22e>GET_SIZE</span>(<span style=color:#a6e22e>HDRP</span>(oldptr));
</span></span><span style=display:flex><span>    copySize <span style=color:#f92672>=</span> <span style=color:#a6e22e>GET_SIZE</span>(<span style=color:#a6e22e>HDRP</span>(newptr));
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> (size <span style=color:#f92672>&lt;</span> copySize)
</span></span><span style=display:flex><span>        copySize <span style=color:#f92672>=</span> size;
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>memcpy</span>(newptr, oldptr, copySize<span style=color:#f92672>-</span>WSIZE);
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>mm_free</span>(oldptr);
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> newptr;
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>/*
</span></span></span><span style=display:flex><span><span style=color:#75715e> * coalesce - Merge freed block if necessary.
</span></span></span><span style=display:flex><span><span style=color:#75715e> * Return: Pointer of the merged block.
</span></span></span><span style=display:flex><span><span style=color:#75715e> */</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>static</span> <span style=color:#66d9ef>void</span><span style=color:#f92672>*</span> <span style=color:#a6e22e>coalesce</span>(<span style=color:#66d9ef>void</span><span style=color:#f92672>*</span> bp)
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>DBG_PRINTF</span>(<span style=color:#e6db74>&#34;Entering coalesce(%p), &#34;</span>, bp);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>/* 
</span></span></span><span style=display:flex><span><span style=color:#75715e>     * We have to save our adjacent block&#39;s address.
</span></span></span><span style=display:flex><span><span style=color:#75715e>     * After `PUT(HDRP(bp), PACK(newsize ,0))` will render NEXT_BLKP(bp) nonsense.
</span></span></span><span style=display:flex><span><span style=color:#75715e>     * It&#39;s really nasty and takes me a lot of time to debug.
</span></span></span><span style=display:flex><span><span style=color:#75715e>     */</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>void</span><span style=color:#f92672>*</span> prev_bp <span style=color:#f92672>=</span> <span style=color:#a6e22e>PREV_BLKP</span>(bp);
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>void</span><span style=color:#f92672>*</span> next_bp <span style=color:#f92672>=</span> <span style=color:#a6e22e>NEXT_BLKP</span>(bp);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>size_t</span> prev_alloc <span style=color:#f92672>=</span> <span style=color:#a6e22e>GET_ALLOC</span>(<span style=color:#a6e22e>FTRP</span>(prev_bp));
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>size_t</span> next_alloc <span style=color:#f92672>=</span> <span style=color:#a6e22e>GET_ALLOC</span>(<span style=color:#a6e22e>HDRP</span>(next_bp));
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>size_t</span> current_size <span style=color:#f92672>=</span> <span style=color:#a6e22e>GET_SIZE</span>(<span style=color:#a6e22e>HDRP</span>(bp));
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>/* Case 0: no need to coalesce */</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> (prev_alloc <span style=color:#f92672>&amp;&amp;</span> next_alloc) {
</span></span><span style=display:flex><span>        <span style=color:#a6e22e>DBG_PRINTF</span>(<span style=color:#e6db74>&#34;no merge</span><span style=color:#ae81ff>\n</span><span style=color:#e6db74>&#34;</span>);
</span></span><span style=display:flex><span>        <span style=color:#a6e22e>insert</span>(bp); 
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> bp; 
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    <span style=color:#75715e>/* 
</span></span></span><span style=display:flex><span><span style=color:#75715e>     * Case 1, previous block is free
</span></span></span><span style=display:flex><span><span style=color:#75715e>     */</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>else</span> <span style=color:#66d9ef>if</span> (<span style=color:#f92672>!</span>prev_alloc <span style=color:#f92672>&amp;&amp;</span> next_alloc) {
</span></span><span style=display:flex><span>        <span style=color:#a6e22e>DBG_PRINTF</span>(<span style=color:#e6db74>&#34;merge prev(%p)</span><span style=color:#ae81ff>\n</span><span style=color:#e6db74>&#34;</span>, prev_bp);
</span></span><span style=display:flex><span>        <span style=color:#75715e>/* setup merged block */</span>
</span></span><span style=display:flex><span>        current_size <span style=color:#f92672>+=</span> <span style=color:#a6e22e>GET_SIZE</span>(<span style=color:#a6e22e>HDRP</span>(prev_bp));
</span></span><span style=display:flex><span>        <span style=color:#a6e22e>delete</span>(prev_bp);
</span></span><span style=display:flex><span>        <span style=color:#a6e22e>PUT</span>(<span style=color:#a6e22e>HDRP</span>(prev_bp), <span style=color:#a6e22e>PACK</span>(current_size, <span style=color:#ae81ff>0</span>));
</span></span><span style=display:flex><span>        <span style=color:#a6e22e>PUT</span>(<span style=color:#a6e22e>FTRP</span>(bp), <span style=color:#a6e22e>PACK</span>(current_size, <span style=color:#ae81ff>0</span>));
</span></span><span style=display:flex><span>        <span style=color:#a6e22e>insert</span>(prev_bp);
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> prev_bp;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    <span style=color:#75715e>/* 
</span></span></span><span style=display:flex><span><span style=color:#75715e>     * Case 2, next block is free, we need to delete next block from free list.
</span></span></span><span style=display:flex><span><span style=color:#75715e>     */</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>else</span> <span style=color:#66d9ef>if</span> (prev_alloc <span style=color:#f92672>&amp;&amp;</span> <span style=color:#f92672>!</span>next_alloc) {
</span></span><span style=display:flex><span>        <span style=color:#a6e22e>DBG_PRINTF</span>(<span style=color:#e6db74>&#34;merge next(%p)</span><span style=color:#ae81ff>\n</span><span style=color:#e6db74>&#34;</span>, next_bp);
</span></span><span style=display:flex><span>        current_size <span style=color:#f92672>+=</span> <span style=color:#a6e22e>GET_SIZE</span>(<span style=color:#a6e22e>HDRP</span>(next_bp));
</span></span><span style=display:flex><span>        <span style=color:#75715e>/* Delete next block from free list */</span>
</span></span><span style=display:flex><span>        <span style=color:#a6e22e>delete</span>(next_bp);
</span></span><span style=display:flex><span>        <span style=color:#75715e>/* setup merged block */</span>
</span></span><span style=display:flex><span>        <span style=color:#a6e22e>PUT</span>(<span style=color:#a6e22e>HDRP</span>(bp), <span style=color:#a6e22e>PACK</span>(current_size, <span style=color:#ae81ff>0</span>));
</span></span><span style=display:flex><span>        <span style=color:#a6e22e>PUT</span>(<span style=color:#a6e22e>FTRP</span>(bp), <span style=color:#a6e22e>PACK</span>(current_size, <span style=color:#ae81ff>0</span>));
</span></span><span style=display:flex><span>        <span style=color:#a6e22e>insert</span>(bp);
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> bp;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    <span style=color:#75715e>/* 
</span></span></span><span style=display:flex><span><span style=color:#75715e>     * Case 3, previous and next block both are free, we need to delete next block from free list.
</span></span></span><span style=display:flex><span><span style=color:#75715e>     */</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>else</span> {
</span></span><span style=display:flex><span>        <span style=color:#a6e22e>DBG_PRINTF</span>(<span style=color:#e6db74>&#34;merge prev(%p) and next(%p)</span><span style=color:#ae81ff>\n</span><span style=color:#e6db74>&#34;</span>, prev_bp, next_bp);
</span></span><span style=display:flex><span>        current_size <span style=color:#f92672>+=</span> <span style=color:#a6e22e>GET_SIZE</span>(<span style=color:#a6e22e>HDRP</span>(prev_bp));
</span></span><span style=display:flex><span>        current_size <span style=color:#f92672>+=</span> <span style=color:#a6e22e>GET_SIZE</span>(<span style=color:#a6e22e>FTRP</span>(next_bp));
</span></span><span style=display:flex><span>        <span style=color:#75715e>/* Delete prev and next block from free list */</span>
</span></span><span style=display:flex><span>        <span style=color:#a6e22e>delete</span>(prev_bp);
</span></span><span style=display:flex><span>        <span style=color:#a6e22e>delete</span>(next_bp);
</span></span><span style=display:flex><span>        <span style=color:#75715e>/* setup merged block */</span>
</span></span><span style=display:flex><span>        <span style=color:#a6e22e>PUT</span>(<span style=color:#a6e22e>HDRP</span>(prev_bp), <span style=color:#a6e22e>PACK</span>(current_size, <span style=color:#ae81ff>0</span>));
</span></span><span style=display:flex><span>        <span style=color:#a6e22e>PUT</span>(<span style=color:#a6e22e>FTRP</span>(next_bp), <span style=color:#a6e22e>PACK</span>(current_size, <span style=color:#ae81ff>0</span>));
</span></span><span style=display:flex><span>        <span style=color:#a6e22e>insert</span>(prev_bp);
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> prev_bp;
</span></span><span style=display:flex><span>    }   
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>/*
</span></span></span><span style=display:flex><span><span style=color:#75715e> * extend_heap - Extend the heap with a free block and coalesce the new free block if necessary.
</span></span></span><span style=display:flex><span><span style=color:#75715e> * Return : new free block&#39;s payload address.
</span></span></span><span style=display:flex><span><span style=color:#75715e> */</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>static</span> <span style=color:#66d9ef>void</span> <span style=color:#f92672>*</span><span style=color:#a6e22e>extend_heap</span>(<span style=color:#66d9ef>size_t</span> words)
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>char</span> <span style=color:#f92672>*</span>bp;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>size_t</span> size;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>/* Allocate even number of words to maintain alignment */</span>
</span></span><span style=display:flex><span>    size <span style=color:#f92672>=</span> (words <span style=color:#f92672>%</span> <span style=color:#ae81ff>2</span>) <span style=color:#f92672>?</span> (words <span style=color:#f92672>+</span> <span style=color:#ae81ff>1</span>) <span style=color:#f92672>*</span> WSIZE : words <span style=color:#f92672>*</span> WSIZE;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> ((<span style=color:#66d9ef>long</span>)(bp <span style=color:#f92672>=</span> <span style=color:#a6e22e>mem_sbrk</span>(size)) <span style=color:#f92672>==</span> <span style=color:#f92672>-</span><span style=color:#ae81ff>1</span>)
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> NULL;
</span></span><span style=display:flex><span>    
</span></span><span style=display:flex><span>    <span style=color:#75715e>/* Initialize free block header/footer and the epilogue header
</span></span></span><span style=display:flex><span><span style=color:#75715e>     * After mem_srbk(size), we are always at the end of epilogue footer, 
</span></span></span><span style=display:flex><span><span style=color:#75715e>     * so we need to change the epilogue ftr to normal header and setup epilogue footer at the end of heap.
</span></span></span><span style=display:flex><span><span style=color:#75715e>     */</span>
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>PUT</span>(<span style=color:#a6e22e>HDRP</span>(bp), <span style=color:#a6e22e>PACK</span>(size, <span style=color:#ae81ff>0</span>));
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>PUT</span>(<span style=color:#a6e22e>FTRP</span>(bp), <span style=color:#a6e22e>PACK</span>(size, <span style=color:#ae81ff>0</span>));
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>PUT</span>(<span style=color:#a6e22e>HDRP</span>(<span style=color:#a6e22e>NEXT_BLKP</span>(bp)), <span style=color:#a6e22e>PACK</span>(<span style=color:#ae81ff>0</span>, <span style=color:#ae81ff>1</span>));
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>/* Coalesce if the previous block was free */</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> <span style=color:#a6e22e>coalesce</span>(bp);
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>/* find_fit - Find freeblock that fits the request size and return it&#39;s bp */</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>static</span> <span style=color:#66d9ef>void</span> <span style=color:#f92672>*</span><span style=color:#a6e22e>find_fit</span>(<span style=color:#66d9ef>size_t</span> asize)
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>DBG_PRINTF</span>(<span style=color:#e6db74>&#34;Entering find_fit(%zu), &#34;</span>, asize);
</span></span><span style=display:flex><span>    <span style=color:#75715e>/* Traverse all the free lists */</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>for</span> ( <span style=color:#66d9ef>int</span> i <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>; i <span style=color:#f92672>&lt;</span> <span style=color:#ae81ff>10</span>; i<span style=color:#f92672>++</span>) {
</span></span><span style=display:flex><span>        <span style=color:#a6e22e>DBG_PRINTF</span>(<span style=color:#e6db74>&#34;LIST_OFFSET: %d</span><span style=color:#ae81ff>\n</span><span style=color:#e6db74>&#34;</span>, i);
</span></span><span style=display:flex><span>        freelist_headp <span style=color:#f92672>=</span> <span style=color:#f92672>*</span>(<span style=color:#66d9ef>char</span> <span style=color:#f92672>**</span>)(seglist_start <span style=color:#f92672>+</span> i <span style=color:#f92672>*</span> WSIZE);
</span></span><span style=display:flex><span>        <span style=color:#75715e>/* Traverse free list */</span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>for</span>(<span style=color:#66d9ef>void</span><span style=color:#f92672>*</span> current <span style=color:#f92672>=</span> freelist_headp; current <span style=color:#f92672>!=</span> NULL; current <span style=color:#f92672>=</span> <span style=color:#a6e22e>FDP</span>(current)) {
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>if</span> (<span style=color:#a6e22e>GET_SIZE</span>(<span style=color:#a6e22e>HDRP</span>(current)) <span style=color:#f92672>&gt;=</span> asize) {
</span></span><span style=display:flex><span>                <span style=color:#a6e22e>DBG_PRINTF</span>(<span style=color:#e6db74>&#34;found %p, size: %u</span><span style=color:#ae81ff>\n</span><span style=color:#e6db74>&#34;</span>, current, <span style=color:#a6e22e>GET_SIZE</span>(<span style=color:#a6e22e>HDRP</span>(current)));
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>return</span> current;
</span></span><span style=display:flex><span>            }
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    <span style=color:#75715e>/* Not found */</span>
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>DBG_PRINTF</span>(<span style=color:#e6db74>&#34;not found</span><span style=color:#ae81ff>\n</span><span style=color:#e6db74>&#34;</span>);
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> NULL;
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>/* place - Place requested block in current free block, split if necessary */</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>static</span> <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>place</span>(<span style=color:#66d9ef>void</span> <span style=color:#f92672>*</span>bp, <span style=color:#66d9ef>size_t</span> asize)
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>DBG_PRINTF</span>(<span style=color:#e6db74>&#34;Entering place(%p)&#34;</span>,bp);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>delete</span>(bp);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>size_t</span> size <span style=color:#f92672>=</span> <span style=color:#a6e22e>GET_SIZE</span>(<span style=color:#a6e22e>HDRP</span>(bp));
</span></span><span style=display:flex><span>    
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> ((size <span style=color:#f92672>-</span> asize) <span style=color:#f92672>&gt;=</span> MINBLOCKSIZE)
</span></span><span style=display:flex><span>    {
</span></span><span style=display:flex><span>        <span style=color:#75715e>/* set up current block */</span>
</span></span><span style=display:flex><span>        <span style=color:#a6e22e>PUT</span>(<span style=color:#a6e22e>HDRP</span>(bp), <span style=color:#a6e22e>PACK</span>(asize, <span style=color:#ae81ff>1</span>));
</span></span><span style=display:flex><span>        <span style=color:#a6e22e>PUT</span>(<span style=color:#a6e22e>FTRP</span>(bp), <span style=color:#a6e22e>PACK</span>(asize, <span style=color:#ae81ff>1</span>));
</span></span><span style=display:flex><span>        <span style=color:#a6e22e>DBG_PRINTF</span>(<span style=color:#e6db74>&#34;split: %p and %p</span><span style=color:#ae81ff>\n</span><span style=color:#e6db74>&#34;</span>, bp, <span style=color:#a6e22e>NEXT_BLKP</span>(bp));
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>         <span style=color:#75715e>/* set up remain block */</span>
</span></span><span style=display:flex><span>        <span style=color:#a6e22e>PUT</span>(<span style=color:#a6e22e>HDRP</span>(<span style=color:#a6e22e>NEXT_BLKP</span>(bp)), <span style=color:#a6e22e>PACK</span>(size<span style=color:#f92672>-</span>asize, <span style=color:#ae81ff>0</span>));
</span></span><span style=display:flex><span>        <span style=color:#a6e22e>PUT</span>(<span style=color:#a6e22e>FTRP</span>(<span style=color:#a6e22e>NEXT_BLKP</span>(bp)), <span style=color:#a6e22e>PACK</span>(size<span style=color:#f92672>-</span>asize, <span style=color:#ae81ff>0</span>));
</span></span><span style=display:flex><span>        <span style=color:#a6e22e>coalesce</span>(<span style=color:#a6e22e>NEXT_BLKP</span>(bp));
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>else</span> {
</span></span><span style=display:flex><span>        <span style=color:#a6e22e>DBG_PRINTF</span>(<span style=color:#e6db74>&#34;no split</span><span style=color:#ae81ff>\n</span><span style=color:#e6db74>&#34;</span>);
</span></span><span style=display:flex><span>        <span style=color:#75715e>/* Waste some space, we have no other way */</span>
</span></span><span style=display:flex><span>        <span style=color:#a6e22e>PUT</span>(<span style=color:#a6e22e>HDRP</span>(bp), <span style=color:#a6e22e>PACK</span>(size, <span style=color:#ae81ff>1</span>));
</span></span><span style=display:flex><span>        <span style=color:#a6e22e>PUT</span>(<span style=color:#a6e22e>FTRP</span>(bp), <span style=color:#a6e22e>PACK</span>(size, <span style=color:#ae81ff>1</span>));
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>/*
</span></span></span><span style=display:flex><span><span style=color:#75715e> * insert - Insert given block pointer to the head of free list.
</span></span></span><span style=display:flex><span><span style=color:#75715e> * insert() is called by free() or place()
</span></span></span><span style=display:flex><span><span style=color:#75715e> */</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>static</span> <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>insert</span>(<span style=color:#66d9ef>void</span><span style=color:#f92672>*</span> bp)
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>DBG_PRINTF</span>(<span style=color:#e6db74>&#34;Entering insert(%p)</span><span style=color:#ae81ff>\n</span><span style=color:#e6db74>&#34;</span>, bp);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>/* Locate freelist */</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>char</span> <span style=color:#f92672>**</span>ptr_to_freelist_headp <span style=color:#f92672>=</span> (<span style=color:#66d9ef>char</span> <span style=color:#f92672>**</span>)(seglist_start <span style=color:#f92672>+</span> <span style=color:#a6e22e>LIST_OFFSET</span>(<span style=color:#a6e22e>GET_SIZE</span>(<span style=color:#a6e22e>HDRP</span>(bp))) <span style=color:#f92672>*</span> WSIZE);
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>DBG_PRINTF</span>(<span style=color:#e6db74>&#34;LIST_OFFSET: %d</span><span style=color:#ae81ff>\n</span><span style=color:#e6db74>&#34;</span>, <span style=color:#a6e22e>LIST_OFFSET</span>(<span style=color:#a6e22e>GET_SIZE</span>(<span style=color:#a6e22e>HDRP</span>(bp))));
</span></span><span style=display:flex><span>    freelist_headp <span style=color:#f92672>=</span> <span style=color:#f92672>*</span>ptr_to_freelist_headp;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>/* List is NULL, make bp as list head */</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> (freelist_headp <span style=color:#f92672>==</span> NULL) {
</span></span><span style=display:flex><span>        <span style=color:#a6e22e>DBG_PRINTF</span>(<span style=color:#e6db74>&#34;Free list is NULL, make %p the head of free list</span><span style=color:#ae81ff>\n</span><span style=color:#e6db74>&#34;</span>, bp);
</span></span><span style=display:flex><span>        <span style=color:#a6e22e>SET_FDP</span>(bp, NULL);
</span></span><span style=display:flex><span>        <span style=color:#a6e22e>SET_BKP</span>(bp, NULL);
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    <span style=color:#75715e>/* insert */</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>else</span> {
</span></span><span style=display:flex><span>        <span style=color:#a6e22e>DBG_PRINTF</span>(<span style=color:#e6db74>&#34;Free list not null,  %p will be new head</span><span style=color:#ae81ff>\n</span><span style=color:#e6db74>&#34;</span>, bp);
</span></span><span style=display:flex><span>        <span style=color:#75715e>/* Set up current block */</span>
</span></span><span style=display:flex><span>        <span style=color:#a6e22e>SET_FDP</span>(bp, freelist_headp);
</span></span><span style=display:flex><span>        <span style=color:#a6e22e>SET_BKP</span>(bp, <span style=color:#ae81ff>0</span>);
</span></span><span style=display:flex><span>        <span style=color:#75715e>/* Set up next block */</span>
</span></span><span style=display:flex><span>        <span style=color:#a6e22e>SET_BKP</span>(freelist_headp, bp);
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>/* Free list head is np now */</span>
</span></span><span style=display:flex><span>    <span style=color:#f92672>*</span>ptr_to_freelist_headp <span style=color:#f92672>=</span> bp;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span>;
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span><span style=color:#75715e>/*
</span></span></span><span style=display:flex><span><span style=color:#75715e> * delete - Remove given block pointer from free list.
</span></span></span><span style=display:flex><span><span style=color:#75715e> * delete() is called by place() or coalesce();
</span></span></span><span style=display:flex><span><span style=color:#75715e> * we dont&#39; call delete() when there&#39;s no free block, so what we deleted is what we inserted.
</span></span></span><span style=display:flex><span><span style=color:#75715e> */</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>static</span> <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>delete</span>(<span style=color:#66d9ef>void</span><span style=color:#f92672>*</span> bp)
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>DBG_PRINTF</span>(<span style=color:#e6db74>&#34;Entering delete(%p)</span><span style=color:#ae81ff>\n</span><span style=color:#e6db74>&#34;</span>, bp);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>/* Locate freelist */</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>char</span> <span style=color:#f92672>**</span>ptr_to_freelist_headp <span style=color:#f92672>=</span> (<span style=color:#66d9ef>char</span> <span style=color:#f92672>**</span>)(seglist_start <span style=color:#f92672>+</span> <span style=color:#a6e22e>LIST_OFFSET</span>(<span style=color:#a6e22e>GET_SIZE</span>(<span style=color:#a6e22e>HDRP</span>(bp))) <span style=color:#f92672>*</span> WSIZE);
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>DBG_PRINTF</span>(<span style=color:#e6db74>&#34;LIST_OFFSET: %d</span><span style=color:#ae81ff>\n</span><span style=color:#e6db74>&#34;</span>, <span style=color:#a6e22e>LIST_OFFSET</span>(<span style=color:#a6e22e>GET_SIZE</span>(<span style=color:#a6e22e>HDRP</span>(bp))));
</span></span><span style=display:flex><span>    <span style=color:#75715e>/* Only one free block */</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span>(<span style=color:#a6e22e>BKP</span>(bp) <span style=color:#f92672>==</span> NULL <span style=color:#f92672>&amp;&amp;</span> <span style=color:#a6e22e>FDP</span>(bp) <span style=color:#f92672>==</span> NULL) {
</span></span><span style=display:flex><span>        <span style=color:#a6e22e>DBG_PRINTF</span>(<span style=color:#e6db74>&#34;Only one free block</span><span style=color:#ae81ff>\n</span><span style=color:#e6db74>&#34;</span>);
</span></span><span style=display:flex><span>        <span style=color:#f92672>*</span>ptr_to_freelist_headp <span style=color:#f92672>=</span> NULL;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    <span style=color:#75715e>/* More than one free block, delete the first block */</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>else</span> <span style=color:#66d9ef>if</span> (<span style=color:#a6e22e>BKP</span>(bp) <span style=color:#f92672>==</span> NULL) {
</span></span><span style=display:flex><span>        <span style=color:#a6e22e>DBG_PRINTF</span>(<span style=color:#e6db74>&#34;More than one free block, delete the first block</span><span style=color:#ae81ff>\n</span><span style=color:#e6db74>&#34;</span>);
</span></span><span style=display:flex><span>        <span style=color:#75715e>/* Fix free list head */</span>
</span></span><span style=display:flex><span>        <span style=color:#a6e22e>SET_BKP</span>(<span style=color:#a6e22e>FDP</span>(bp), NULL);
</span></span><span style=display:flex><span>        <span style=color:#a6e22e>DBG_PRINTF</span>(<span style=color:#e6db74>&#34;New list head: %p</span><span style=color:#ae81ff>\n</span><span style=color:#e6db74>&#34;</span>, <span style=color:#a6e22e>FDP</span>(bp));
</span></span><span style=display:flex><span>        <span style=color:#f92672>*</span>ptr_to_freelist_headp <span style=color:#f92672>=</span> <span style=color:#a6e22e>FDP</span>(bp);
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    <span style=color:#75715e>/* More than one free block, delete the last block */</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>else</span> <span style=color:#66d9ef>if</span> (<span style=color:#a6e22e>FDP</span>(bp) <span style=color:#f92672>==</span> NULL) {
</span></span><span style=display:flex><span>        <span style=color:#a6e22e>DBG_PRINTF</span>(<span style=color:#e6db74>&#34;More than one free block, delete the last block</span><span style=color:#ae81ff>\n</span><span style=color:#e6db74>&#34;</span>);
</span></span><span style=display:flex><span>        <span style=color:#a6e22e>SET_FDP</span>(<span style=color:#a6e22e>BKP</span>(bp), NULL);
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    <span style=color:#75715e>/* More than two free block, delete the middle block */</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>else</span> {
</span></span><span style=display:flex><span>        <span style=color:#a6e22e>DBG_PRINTF</span>(<span style=color:#e6db74>&#34;More than two free block, delete the middle block</span><span style=color:#ae81ff>\n</span><span style=color:#e6db74>&#34;</span>);
</span></span><span style=display:flex><span>        <span style=color:#a6e22e>SET_FDP</span>(<span style=color:#a6e22e>BKP</span>(bp), <span style=color:#a6e22e>FDP</span>(bp));
</span></span><span style=display:flex><span>        <span style=color:#a6e22e>SET_BKP</span>(<span style=color:#a6e22e>FDP</span>(bp), <span style=color:#a6e22e>BKP</span>(bp));
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>static</span> <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>check_freelist</span>()
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>printf</span>(<span style=color:#e6db74>&#34;---------------CHECK FREE LIST START----------------------</span><span style=color:#ae81ff>\n</span><span style=color:#e6db74>&#34;</span>);
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>for</span> ( <span style=color:#66d9ef>int</span> i <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>; i <span style=color:#f92672>&lt;</span> <span style=color:#ae81ff>10</span>; i<span style=color:#f92672>++</span>) {
</span></span><span style=display:flex><span>        <span style=color:#a6e22e>DBG_PRINTF</span>(<span style=color:#e6db74>&#34;LIST_OFFSET: %d</span><span style=color:#ae81ff>\n</span><span style=color:#e6db74>&#34;</span>, i);
</span></span><span style=display:flex><span>        freelist_headp <span style=color:#f92672>=</span> <span style=color:#f92672>*</span>(<span style=color:#66d9ef>char</span> <span style=color:#f92672>**</span>)(seglist_start <span style=color:#f92672>+</span> i <span style=color:#f92672>*</span> WSIZE);
</span></span><span style=display:flex><span>        <span style=color:#a6e22e>printf</span>(<span style=color:#e6db74>&#34;freelist_headp: %p</span><span style=color:#ae81ff>\n</span><span style=color:#e6db74>&#34;</span>, freelist_headp);
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>char</span> <span style=color:#f92672>*</span>cur, <span style=color:#f92672>*</span>next;
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span> ((cur <span style=color:#f92672>=</span> freelist_headp) <span style=color:#f92672>!=</span> NULL)
</span></span><span style=display:flex><span>        {
</span></span><span style=display:flex><span>            <span style=color:#a6e22e>printf</span>(<span style=color:#e6db74>&#34;Free List: %p&lt;-&#34;</span>, <span style=color:#a6e22e>BKP</span>(cur));
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>while</span>(cur <span style=color:#f92672>!=</span> NULL)
</span></span><span style=display:flex><span>            {
</span></span><span style=display:flex><span>                next <span style=color:#f92672>=</span> <span style=color:#a6e22e>FDP</span>(cur);
</span></span><span style=display:flex><span>                <span style=color:#a6e22e>printf</span>(<span style=color:#e6db74>&#34;%p(size: %u)-&gt;&#34;</span>, cur, <span style=color:#a6e22e>GET_SIZE</span>(<span style=color:#a6e22e>HDRP</span>(cur)));
</span></span><span style=display:flex><span>                <span style=color:#75715e>/* Check if next free block points to us */</span>
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>if</span>(next <span style=color:#f92672>!=</span> NULL <span style=color:#f92672>&amp;&amp;</span> <span style=color:#a6e22e>BKP</span>(next) <span style=color:#f92672>!=</span> cur) {
</span></span><span style=display:flex><span>                    <span style=color:#a6e22e>printf</span>(<span style=color:#e6db74>&#34;</span><span style=color:#ae81ff>\n</span><span style=color:#e6db74>Next free block does not point to current block!</span><span style=color:#ae81ff>\n</span><span style=color:#e6db74>&#34;</span>);
</span></span><span style=display:flex><span>                    <span style=color:#a6e22e>exit</span>(<span style=color:#ae81ff>1</span>);
</span></span><span style=display:flex><span>                }
</span></span><span style=display:flex><span>                cur <span style=color:#f92672>=</span> next;
</span></span><span style=display:flex><span>            }
</span></span><span style=display:flex><span>            <span style=color:#a6e22e>printf</span>(<span style=color:#e6db74>&#34;%p</span><span style=color:#ae81ff>\n</span><span style=color:#e6db74>&#34;</span>, NULL);
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>else</span>
</span></span><span style=display:flex><span>        {
</span></span><span style=display:flex><span>            <span style=color:#a6e22e>printf</span>(<span style=color:#e6db74>&#34;Free List is NULL.</span><span style=color:#ae81ff>\n</span><span style=color:#e6db74>&#34;</span>);
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>printf</span>(<span style=color:#e6db74>&#34;--------------- CHECK FREE LIST END ----------------------</span><span style=color:#ae81ff>\n</span><span style=color:#e6db74>&#34;</span>);
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>static</span> <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>mm_checkheap</span>(<span style=color:#66d9ef>int</span> verbose)
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>check_freelist</span>();
</span></span><span style=display:flex><span>    <span style=color:#75715e>/* 
</span></span></span><span style=display:flex><span><span style=color:#75715e>     * What we need to check:
</span></span></span><span style=display:flex><span><span style=color:#75715e>     * Check epilogue and prologue blocks
</span></span></span><span style=display:flex><span><span style=color:#75715e>     * Check each block’s address alignment
</span></span></span><span style=display:flex><span><span style=color:#75715e>     * Check heap boundaries
</span></span></span><span style=display:flex><span><span style=color:#75715e>     * Check each block’s header and footer: size(minimum size, slignment), previous/net allocate/free bit consistency, header and footer matching each other
</span></span></span><span style=display:flex><span><span style=color:#75715e>     * Check coalescing: no two consecutive free blocks in the heap
</span></span></span><span style=display:flex><span><span style=color:#75715e>     */</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>char</span> <span style=color:#f92672>*</span>header_start <span style=color:#f92672>=</span> heap_listp <span style=color:#f92672>+</span> <span style=color:#ae81ff>11</span> <span style=color:#f92672>*</span> WSIZE; <span style=color:#75715e>/* Prologue header */</span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>/* Check prologue header */</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> (<span style=color:#a6e22e>GET_SIZE</span>(header_start) <span style=color:#f92672>!=</span> DSIZE <span style=color:#f92672>||</span> <span style=color:#a6e22e>GET_ALLOC</span>(header_start) <span style=color:#f92672>!=</span> <span style=color:#ae81ff>1</span>) {
</span></span><span style=display:flex><span>        <span style=color:#a6e22e>printf</span>(<span style=color:#e6db74>&#34;Prologue Header Malformed. Size: %d, Alloc: %d</span><span style=color:#ae81ff>\n</span><span style=color:#e6db74>&#34;</span>, <span style=color:#a6e22e>GET_SIZE</span>(header_start), <span style=color:#a6e22e>GET_ALLOC</span>(header_start));
</span></span><span style=display:flex><span>        <span style=color:#a6e22e>exit</span>(<span style=color:#ae81ff>1</span>);
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> (<span style=color:#a6e22e>GET_SIZE</span>(header_start <span style=color:#f92672>+</span> WSIZE) <span style=color:#f92672>!=</span> DSIZE <span style=color:#f92672>||</span> <span style=color:#a6e22e>GET_ALLOC</span>(header_start <span style=color:#f92672>+</span> WSIZE) <span style=color:#f92672>!=</span> <span style=color:#ae81ff>1</span>) {
</span></span><span style=display:flex><span>        <span style=color:#a6e22e>printf</span>(<span style=color:#e6db74>&#34;Prologue Footer Malformed.</span><span style=color:#ae81ff>\n</span><span style=color:#e6db74>&#34;</span>);
</span></span><span style=display:flex><span>        <span style=color:#a6e22e>exit</span>(<span style=color:#ae81ff>1</span>);
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>/* Traverse blocks, check status */</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>char</span> <span style=color:#f92672>*</span>header <span style=color:#f92672>=</span> header_start <span style=color:#f92672>+</span> DSIZE;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>while</span> ( <span style=color:#a6e22e>GET_SIZE</span>(header) <span style=color:#f92672>!=</span> <span style=color:#ae81ff>0</span>) {
</span></span><span style=display:flex><span>        <span style=color:#75715e>/* Alignment */</span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span>((<span style=color:#66d9ef>unsigned</span> <span style=color:#66d9ef>long</span>)(header <span style=color:#f92672>+</span> WSIZE) <span style=color:#f92672>%</span> ALIGNMENT) {
</span></span><span style=display:flex><span>            <span style=color:#a6e22e>printf</span>(<span style=color:#e6db74>&#34;Address not aligned!</span><span style=color:#ae81ff>\n</span><span style=color:#e6db74>&#34;</span>);
</span></span><span style=display:flex><span>            <span style=color:#a6e22e>exit</span>(<span style=color:#ae81ff>1</span>);
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>        <span style=color:#75715e>/* No adjacent free block */</span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>char</span> <span style=color:#f92672>*</span>next <span style=color:#f92672>=</span> header <span style=color:#f92672>+</span> <span style=color:#a6e22e>GET_SIZE</span>(header);
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span> (<span style=color:#f92672>!</span><span style=color:#a6e22e>GET_ALLOC</span>(header) <span style=color:#f92672>&amp;&amp;</span> <span style=color:#f92672>!</span><span style=color:#a6e22e>GET_ALLOC</span>(next)) {
</span></span><span style=display:flex><span>                <span style=color:#a6e22e>printf</span>(<span style=color:#e6db74>&#34;Adjacent free block!</span><span style=color:#ae81ff>\n</span><span style=color:#e6db74>&#34;</span>);
</span></span><span style=display:flex><span>                <span style=color:#a6e22e>printf</span>(<span style=color:#e6db74>&#34;Current header: %p, size: %d alloc: %dx</span><span style=color:#ae81ff>\n</span><span style=color:#e6db74>&#34;</span>, header, <span style=color:#a6e22e>GET_SIZE</span>(header), <span style=color:#a6e22e>GET_ALLOC</span>(header));
</span></span><span style=display:flex><span>                <span style=color:#a6e22e>printf</span>(<span style=color:#e6db74>&#34;Next header: %p, size: %d alloc: %dx</span><span style=color:#ae81ff>\n</span><span style=color:#e6db74>&#34;</span>, header, <span style=color:#a6e22e>GET_SIZE</span>(next), <span style=color:#a6e22e>GET_ALLOC</span>(next));
</span></span><span style=display:flex><span>                <span style=color:#a6e22e>check_freelist</span>();
</span></span><span style=display:flex><span>                <span style=color:#a6e22e>exit</span>(<span style=color:#ae81ff>1</span>);
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>        header <span style=color:#f92672>=</span> next;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>REF：</p><p><a href=https://github.com/HarshTrivedi/malloc title="HarshTrivedi/malloc: An implementation of dynamic memory allocator in C using explicit free list, as according to the lab assignment of CS-APP book , reaching 91 % efficiency. (github.com)" rel="noopener external nofollow noreferrer" target=_blank class=exturl>HarshTrivedi/malloc: An implementation of dynamic memory allocator in C using explicit free list, as according to the lab assignment of CS-APP book , reaching 91 % efficiency. (github.com)
<i class="fa fa-external-link-alt"></i></a></p><p><a href=https://zhuanlan.zhihu.com/p/150100073 title="CSAPP:Lab5-Malloc Lab - 知乎 (zhihu.com)" rel="noopener external nofollow noreferrer" target=_blank class=exturl>CSAPP:Lab5-Malloc Lab - 知乎 (zhihu.com)
<i class="fa fa-external-link-alt"></i></a></p><p><a href=https://www.jianshu.com/p/48d5d0554b3b title="六 Malloc Lab - 简书 (jianshu.com)" rel="noopener external nofollow noreferrer" target=_blank class=exturl>六 Malloc Lab - 简书 (jianshu.com)
<i class="fa fa-external-link-alt"></i></a></p></div><footer class=post-footer><div class=post-tags><a href=/tags/csapp>CSAPP</a>
<a href=/tags/malloc-lab>Malloc Lab</a></div><div class=addthis_inline_share_toolbox style=text-align:center></div><hr><div class=post-copyright><img src=/imgs/cc/cc.svg width=75 height=75 align=right alt=共享知识><ul><li class=post-copyright-title><strong>文章标题：</strong>
CSAPP Malloc Lab</li><li class=post-copyright-author><strong>本文作者：</strong>
Zero</li><li class=post-copyright-link><strong>本文链接：</strong>
<a id=post-cr-link href=https://izeroo.cn/post/csapp-malloc-lab.html title="CSAPP Malloc Lab">https://izeroo.cn/post/csapp-malloc-lab.html</a></li><li class=post-copyright-license><strong>版权声明：</strong>
本博客所有文章除特别声明外，均采用 <i class="fab fa-fw fa-creative-commons"></i><a target=_blank href=https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh>BY-NC-SA</a> 许可协议。转载请注明出处！</li></ul></div><div class=post-nav><div class="post-nav-next post-nav-item"><a href=/post/how2heap.html rel=next title=how2heap全系列（持续更新）><i class="fa fa-chevron-left"></i> how2heap全系列（持续更新）</a></div><div class="post-nav-prev post-nav-item"><a href=/post/canary-bypass.html rel=prev title=Canary绕过>Canary绕过
<i class="fa fa-chevron-right"></i></a></div></div></footer></article></div><div id=comments class=post-comments><div class=comment-head><div class=comment-headline><i class="fas fa-comments fa-fw"></i>
<span>评论交流</span></div></div><div class=comment-wrap><div><div class=comment-loading><i class="fa fa-sync fa-spin"></i></div><div class=waline-container></div></div></div></div></div></main><footer class=footer><div class=footer-inner><div class=copyright>&copy;
<span itemprop=copyrightYear>2021 - 2023</span>
<span class=with-love><i class="fa fa-heart"></i></span>
<span class=author itemprop=copyrightHolder>Zero</span></div><div class=powered-by>由 <a href=https://gohugo.io title=0.111.3 target=_blank>Hugo</a> & <a href=https://github.com/hugo-next/hugo-theme-next title=4.5.3 target=_blank>Hugo NexT.Gemini</a> 强力驱动</div><div class=beian><a href=https://beian.miit.gov.cn target=_blank>鄂ICP备2021002440号-1</a>
<img src=/imgs/gongan.png alt=鄂公网安备>
<a href="http://www.beian.gov.cn/portal/registerSystemInfo?recordcode=42112702000080" target=_blank>鄂公网安备 42112702000080 号</a></div></div></footer><script type=text/javascript src=https://unpkg.com/animejs@3.2.1/lib/anime.min.js defer></script>
<script type=text/javascript src=https://unpkg.com/viewerjs@1.11.0/dist/viewer.min.js defer></script>
<script class=next-config data-name=main type=application/json>{"bookmark":{"color":"#222","enable":false,"save":"manual"},"copybtn":true,"darkmode":true,"giscus":{"cfg":{"category":"Comments","categoryid":null,"emit":false,"inputposition":"top","mapping":"title","reactions":false,"repo":"username/repo-name","repoid":null,"theme":"preferred_color_scheme"},"js":"https://giscus.app/client.js"},"hostname":"https://izeroo.cn","i18n":{"ds_day":" 天前","ds_days":" 天 ","ds_hour":" 小时前","ds_hours":" 小时 ","ds_just":"刚刚","ds_min":" 分钟前","ds_mins":" 分钟","ds_month":" 个月前","ds_years":" 年 ","empty":"没有找到任何搜索结果：${query}","hits":"找到 ${hits} 个搜索结果","hits_time":"找到 ${hits} 个搜索结果（用时 ${time} 毫秒）","placeholder":"搜索..."},"lang":"zh-CN","lazyload":false,"localSearch":{"enable":true,"path":"/searchindexes.xml","preload":false,"topnperarticle":-1,"trigger":"auto","unescape":false},"motion":{"async":true,"enable":true,"transition":{"collheader":"fadeInLeft","postblock":"fadeIn","postbody":"fadeInDown","postheader":"fadeInDown","sidebar":"fadeInUp"}},"postmeta":{"comments":{"enable":true,"plugin":"waline"},"views":{"enable":true,"plugin":"busuanzi"}},"root":"/","scheme":"Gemini","sidebar":{"display":"post","offset":12,"padding":18,"position":"left","width":256},"vendor":{"plugins":"unpkg","router":"https://unpkg.com"},"version":"4.5.3","waline":{"cfg":{"emoji":false,"imguploader":false,"pageview":"#waline-pageview-count","placeholder":"请文明发言哟 ヾ(≧▽≦*)o","reaction":true,"reactiontext":["点赞","踩一下","得意","不屑","尴尬","睡觉"],"reactiontitle":"你认为这篇文章怎么样？","requiredmeta":["nick","mail"],"serverurl":"https://waline.izeroo.cn","sofa":"快来发表你的意见吧 (≧∀≦)ゞ","wordlimit":200},"css":{"alias":"waline","file":"dist/waline.css","name":"@waline/client","version":"2.13.0"},"js":{"alias":"waline","file":"dist/waline.js","name":"@waline/client","version":"2.13.0"}}}</script><script type=text/javascript src=/js/main.min.172ae7dfd181813113a42cd33e0d01ee7d239870a49495e95982cc76539f01bb.js defer></script></body></html>